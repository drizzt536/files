; NOTE: these only work on windows because it uses cl as the first argument.

%ifndef RBIT8_INC
%define RBIT8_INC

%ifndef RBIT8_OPTIMIZATION
	%xdefine RBIT8_OPTIMIZATION balanced
%endif

%if 0
uint32_t reverse(uint32_t x, uint8_t bits) {
	x = (x & 0x55555555) <<  1 | (x & 0xAAAAAAAA) >>  1; // Swap _<>_
	x = (x & 0x33333333) <<  2 | (x & 0xCCCCCCCC) >>  2; // Swap __<>__
	x = (x & 0x0F0F0F0F) <<  4 | (x & 0xF0F0F0F0) >>  4; // Swap ____<>____
	x = (x & 0x00FF00FF) <<  8 | (x & 0xFF00FF00) >>  8; // Swap ...
	x = (x & 0x0000FFFF) << 16 | (x & 0xFFFF0000) >> 16; // Swap ...
	return x >> (32 - bits);
}
%endif

%ifidni RBIT8_OPTIMIZATION, speed
	; raw lookup table

	segment rdata

	rbit8_table:
		db 0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0
		db 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0
		db 0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8
		db 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8
		db 0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4
		db 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4
		db 0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec
		db 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc
		db 0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2
		db 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2
		db 0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea
		db 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa
		db 0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6
		db 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6
		db 0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee
		db 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe
		db 0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1
		db 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1
		db 0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9
		db 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9
		db 0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5
		db 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5
		db 0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed
		db 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd
		db 0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3
		db 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3
		db 0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb
		db 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb
		db 0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7
		db 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7
		db 0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef
		db 0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff

	segment text

	; uint8_t rbit8(uint8_t x) {
	;     return rbit8_table[x];
	; }
	rbit8:
		; 3 instructions (11 bytes), 256 rdata bytes, 267 total
		movzx	rcx, cl
		mov		al, [rbit8_table + rcx]
		ret
%elifidni RBIT8_OPTIMIZATION, balanced
	; lookup table with some manipulation

	segment rdata

	rbit8_table:
		;; reversed bits of `index`
		;; python code: [int(f"{x:04b}"[::-1], 2) for x in range(16)]
		db 0,  8, 4, 12
		db 2, 10, 6, 14
		db 1,  9, 5, 13
		db 3, 11, 7, 15

	segment text

	; uint8_t rbit8(uint8_t x) {
	;     return rbit8_table[x & 15] << 4 | rbit8_table[x >> 4];
	; }
	rbit8:
		;; 10 instructions (31 bytes), 16 rdata bytes, 47 bytes total
		;; the next two instructions are basically required.
		movzx	rcx, cl					;; rcx %= 256. not technically required.

		mov 	rax, rcx				;; clear bytes other than `al`.
		shr 	al, 4
		mov 	al, [rbit8_table + rax]	;; al = y[x >> 4]

		and 	cl, 15
		mov 	cl, [rbit8_table + rcx]
		shl 	cl, 4					;; cl = y[x & 15] << 4

		or  	al, cl
		ret
%elifidni RBIT8_OPTIMIZATION, recurse
	; rbit8 using rbit4

	%ifndef RBIT4_INC
		%include "rbit4.nasm"
	%endif

	;; total: 26 instructions, 67 bytes

	segment text

	; uint8_t rbit8(uint8_t x) {
	;     return rbit4(x) << 4 | rbit4(x >> 4);
	; }
	rbit8:
		;; 11 instructions (34 bytes), 0 rdata bytes, 34 bytes total
		xor 	al, al		;; clear return register.
		mov 	r8b, cl		;; copy cl for later.

		and		cl, 15
		call 	rbit4		;; al = y[x], dl = x

		shl 	al, 4
		mov 	r9b, al		;; r9b = y[x & 15] << 4

		mov 	cl, r8b
		shr 	cl, 4
		call	rbit4		;; al = y[x >> 4], dl

		or  	al, r9b
		ret
%elifidni RBIT8_OPTIMIZATION, nordata
	; use a pure algorithm. no rdata bytes and no rbit4.

	; uint8_t rbit8(uint8_t x) {
	;     // assume x < 2^4
	;     x = (x & 0b01010101) << 1 | (x & 0b10101010) >> 1; // Swap _<>_
	;     x = (x & 0b00110011) << 2 | (x & 0b11001100) >> 2; // Swap __<>__
	;     // asm("rol %%cl, 4");
	;     x = (x & 0b00001111) << 4 | (x & 0b11110000) >> 4; // Swap ____<>____
	;     return x;
	; }
	rbit8:
		mov 	al, cl

		;; swap _<>_
		and 	al, 85 ;; 01010101b
		shl 	al, 1
		shr 	cl, 1
		and 	cl, 85 ;; 01010101b
		or  	cl, al

		;; swap __<>__
	%if %isdef(Ofast) && (%isempty(Ofast) || Ofast == 1) ;; 1 or blank.
		;; opcode: 8D048D00000000
		;; larger opcode, less instructions
		lea 	eax, [4*rcx]
	%else
		;; smaller code size, more instructions
		;; opcodes: 88C8 00C0
		mov 	al, cl
		add 	al, al ; shl al, 2
	%endif
		and 	cl, -52 ;; 11001100b
		and 	al, -52 ;; 11001100b
		shr 	cl, 2
		or  	al, cl

		;; swap ____<>____
		rol 	al, 4

		;; return x;
		ret
%else
	%error "RBIT8_OPTIMIZATION" must be speed, balanced, recurse, or nordata (case insensitive)
%endif

%endif
