%YAML 1.2

# this is a fork of this:
    # https://github.com/13xforever/x86-assembly-textmate-bundle/blob/master/x86_64 Assembly.tmbundle/Syntaxes/Nasm Assembly.sublime-syntax
    # - it is up to date, but missing key things like preprocessor functions, `%if 0` comment blocks, support for `ctrl+/`, `%rmacro`, etc.
    # - I don't have control of it, or its update cycle/content.
    # - it was made for YASM and highlights things like `ddq` and `dqword` which don't work in NASM.

# Last Used NASM Commit:
    # (https://github.com/netwide-assembler/nasm/commit/<commit>)

    # Merge remote-tracking branch 'github/nasm-2.16.xx'
    # 699684bf1782eeb8e5b03135820aef83ef2d990c

    # this one is also used, but none in-between these were used
    # 8d62e99e140f20dcab6d1568fe9b3734b5f3b61d

# TODO: everywhere that has identifers, allow macro indirection in it.

# TODO: add autocomplete things:
    # header guard
    # common non-preprocessor things
# TODO: add single line comments to the rest of the preprocessor directives.

file_extensions: [nasm, asm, inc, mac]
scope: source.nasm
name: NASM

variables:
  # base identifier character.
  base: (?i:[bdhoqtxy])
  zero: (?:-?(?:0[0_]*{{base}}?|0{{base}}0[0_]*|\$0[0_]*|0+\.0+{{base}}?|0{{base}}0+\.0+))
  # TODO: `nonzero` doesn't work with floats or _
  nonzero: (?:-?(?i:[\da-f]*[1-9a-f][\da-f]*{{base}}?|0{{base}}[\da-f]*[1-9a-f][\da-f]*))
  num_bin: (?:[01][01_]*)
  num_oct: (?:[0-7][0-7_]*)
  num_dec: (?:\d[\d_]*)
  num_hex: (?i:[\da-f][\da-f_]*)

  # all the characters up until a comment, line-continuation, or newline.
  # *? to stop at the first one that appears.
  line_rem: (?:[^\s;].*?(?=;|\\?$\n?))

  # For some reason, NASM allows truncated cpu names like this:
      # cpu katmai
      # cpu katma
      # cpu katm
      # cpu kat
      # cpu ka
      # cpu k
  # If you do something like `p`, it is unclear if it is p2, pentium, ppro, etc.
  # these are some intuitive ones (the rest are not highlighted):
      # def   -> default
      # ivy   -> ivybridge
      # kat   -> katmai
      # pent  -> pentium? (I think.)
      # sandy -> sandybridge
      # west  -> westmere
      # will  -> willamette
  valid_cpu: (?i:(?:80|[1-6])86|x86(?:-64)?|ia-?64|p[2346]|itani(?:c|um)|(?:sandy|ivy)(?:bridge)?|pent(?:ium(?:mmx|pro|ii)?)?|(?:late|e)?vex|ppro|x64|kat(?:mai)?|will(?:amette)?|prescott|merced|nehalem|west(?:mere)?|def(?:ault)?|any|all)
  num_bin_exp: (?:p[+-]?{{num_dec}})
  num_dec_exp: (?:e[+-]?{{num_dec}})
  if_directive: (?:if{{valid_condition}})

  # just using `\b` doesn't work. example: `\bcpu\b` matches `?cpu?`.
  # this will think it is a directive, when it is a label.
  end_b: (?![~#$.?@\w])
  stt_b: (?<![#$.?@\w])

  # All supersets are allowed as aliases. i.e. `pp-rep` is allowed, even though `pp-rep-negative` is the only one it encompasses.
  # ones like `bad`, `unknown` `not`, `orphan`, etc. are allowed by NASM, but are not included here because they don't make any sense.
  # `gnu-elf-extensions` was removed in version 2.15.
  # `macro-selfref` was removed at some point, probably around 2.15.
  # `empty-pragma` may or may not have been a thing at some point.
  warning_class: (?:{{stt_b}}(?i:prefix(?:-(?:bnd|hle|lock(?:-(?:error|xchg))?|opsize|seg))?|ea(?:-(?:absolute|dispsize))?|float(?:-(?:denorm|(?:over|under)flow|toolong))?|label(?:-orphan|-redef(?:-late)?)?|macro-def|macro-(?:def-(?:case|greedy|param)-single|defaults|params(?:-(?:legacy|multi|single))?)|(?:bad|unknown|not-my)-pragma|pragma(?:-(?:bad|empty|na|unknown))?|obsolete(?:-(?:nop|removed|valid))?|pp(?:-(?:else(?:-(?:elif|else))?|empty(?:-braces)?|environment|macro(?:-(?:def(?:-(?:case|greedy|param)(?:-single)?)?|params(?:-(?:legacy|multi|single))?|defaults|redef(?:-multi)?))?|open(?:-(?:brac(?:e|ket)s|string))?|rep(?:-negative)?|sel(?:-range)?|trailing))?|reloc(?:-(?:abs|rel)(?:-(?:byte|[dq]?word))?)?|all|bnd|hle|ptr|lock|user|phase|other|zeroing|regsize|forward|db-empty|zext-reloc|environment|negative-rep|orphan-labels|unknown-warning|number-overflow|warn-stack-empty)(?=\]|\s))
  identifier_body: (?:[\w#$.?@~]*)

  # this is the order the conditions are mentioned in nasmdoc4.
  # `%ifdifi` doesn't actually exist. it ignores its argument and is always false. so basically just `%comment` from when that existed in like 2011.
  valid_condition: (?:n?(?:def|macro|ctx|idni?|id|num|str|token|empty|env|defalias|usable|using|difi)?)
  valid_identifier: (?:[\w$?@]{{identifier_body}})

  # the same as line_rem, but with `\]` as an additional stop character.
  line_rem_bracketed: (?:[^\s;\]].*?(?=;|\]|\\?$\n?))

contexts:
  prototype:
    - include: comments

  main:
    - include: line-continuation
    - include: comments
    - include: prefixes
    - include: decorators
    - include: data-types
    - include: registers
    - include: mnemonics
    - include: strings
    - include: numbers
    - include: operators
    - include: support
    - include: directives
    - include: bracket-directives
    - include: entities
    - include: structs
    - include: preprocessor
    - include: labels

  line-continuation:
    - match: (\\)$\n?
      captures:
        1: punctuation.separator.continuation.nasm
    - match: (\\)([^\S\n]+)$\n?
      captures:
        1: punctuation.separator.continuation.nasm
        2: invalid.illegal.space-after-continuation.nasm
  line-ending:
    - match: $\n
      pop: true
  whitespace:
    - match: '[^\S\n]+'
    - include: line-continuation
    - include: line-ending
  pop:
    - match: (?=.|$)
      pop: true
  pop-if-not-whitespace:
    - match: (?=\S)
      pop: true

  # TODO: should numbers use {{stt_b}}/{{end_b}}?
  numbers:
    - include: floating-point
    - include: integers
  floating-point:
    # binary
    - match: (?i)\b0[by]{{num_bin}}\.(?:{{num_bin}}?{{num_bin_exp}}?\b)?
      scope: constant.numeric.binary.floating-point.nasm
    - match: (?i)\b0[by]{{num_bin}}{{num_bin_exp}}\b
      scope: constant.numeric.binary.floating-point.nasm
    # octal
    - match: (?i)\b0[oq]{{num_oct}}\.(?:{{num_oct}}?{{num_bin_exp}}?\b)?
      scope: constant.numeric.octal.floating-point.nasm
    - match: (?i)\b0[oq]{{num_oct}}{{num_bin_exp}}\b
      scope: constant.numeric.octal.floating-point.nasm
    # decimal
    - match: (?i)\b(?:0[dt])?{{num_dec}}\.(?:{{num_dec}}?{{num_dec_exp}}?\b)?
      scope: constant.numeric.decimal.floating-point.nasm
    - match: (?i)\b{{num_dec}}{{num_dec_exp}}\b
      scope: constant.numeric.decimal.floating-point.nasm
    # - match: (?i)\.{{num_dec}}{{num_dec_exp}}?\b
      # scope: invalid.illegal.constant.numeric.decimal.floating-point.nasm
    - match: (?i)\b{{num_dec}}p{{num_dec}}?\b
      scope: constant.numeric.decimal.packed-bcd.nasm
    # hex
    - match: (?i)\b0[xh]{{num_hex}}\.(?:{{num_hex}}?{{num_bin_exp}}?\b)?
      scope: constant.numeric.hex.floating-point.nasm
    - match: (?i)\b0[xh]{{num_hex}}{{num_bin_exp}}\b
      scope: constant.numeric.hex.floating-point.nasm
    - match: (?i)\$[0-9]\_?{{num_hex}}?\.(?:{{num_hex}}?{{num_bin_exp}}?\b)?
      scope: constant.numeric.hex.floating-point.nasm
    - match: (?i)\$[0-9]\_?{{num_hex}}{{num_bin_exp}}\b
      scope: constant.numeric.hex.floating-point.nasm
  integers:
    - match: (?i)\b(?:0[by]{{num_bin}}|{{num_bin}}[by])\b
      scope: constant.numeric.binary.nasm
    - match: (?i)\b(?:0[oq]{{num_oct}}|{{num_oct}}[oq])\b
      scope: constant.numeric.octal.nasm
    - match: (?i)\b(?:0[dt]{{num_dec}}|{{num_dec}}[dt]?)\b
      scope: constant.numeric.decimal.nasm
    - match: (?i)(?:\$[0-9]\_?{{num_hex}}?)\b
      scope: constant.numeric.hex.nasm
    - match: (?i)\b(?:0[xh]{{num_hex}}|{{num_hex}}[hx])\b
      scope: constant.numeric.hex.nasm
  operators:
    - match: \%%?\s|[+\-*/]
      scope: keyword.operator.arithmetic.nasm
    - match: \|\||&&|\^\^
      scope: keyword.operator.logical.nasm
    - match: <<<?|>>>?|[|&^~]
      scope: keyword.operator.bitwise.nasm
    - match: \!=|[=<>]
      scope: keyword.operator.comparison.nasm
    - match: \!
      scope: keyword.operator.logical.nasm
    - match: \,
      scope: punctuation.separator.comma.nasm
    - match: '{{stt_b}}(?i:seg|wrt){{end_b}}'
      scope: keyword.operator.word.nasm
    # TODO: ternary operator things don't have to be surrounded by space
    # for instance, `1234? 4 : 5` is fine. I haven't checked any other cases.
    - match: (?:^|\s)(\?)(?:\s|$)
      captures:
        1: keyword.operator.ternary.question.nasm
    - match: (?:^|\s)(:)(?:\s|$)
      captures:
        1: keyword.operator.ternary.colon.nasm

  # ordered by most to least directivey
  directives:
    # TODO: add line continuations in directives.
    # TODO: for the directives like `BITS 64` that transform to `[BITS 64]`,
        # add separate highlighting for it.
        # and change these to only work at the start of lines.
    - match: (?i){{stt_b}}(?:ideal|jumps|p[345]86|end){{end_b}}
      scope: invalid.deprecated.tasm.nasm
    - match: (?i){{stt_b}}(?:section|segment){{end_b}}
      scope: support.function.directive.nasm
      push: [section-parameters, section-name]
    - match: (?i){{stt_b}}(?:absolute|common|static){{end_b}}
      scope: support.function.directive.nasm
    - match: (?i){{stt_b}}(?:bits|use(?:16|32|64|abs|rel|bnd|nobnd)|org|uppercase|safeseh|osabi){{end_b}}
      scope: support.function.directive.nasm
    - match: (?i){{stt_b}}(default)\b\s*(rel|abs|bnd|nobnd)?{{end_b}}
      captures:
        1: support.function.directive.nasm
        2: support.constant.directive.nasm
    - match: (?i){{stt_b}}group{{end_b}}
      scope: support.function.directive.nasm
      push: section-name
    # TODO: the things in the next few directives are marked as case insensitive.
    # i.e. the `import` in `extern :import`, `default` in `global default`, etc.
    # Test to see if they actually are.
    - match: (?i){{stt_b}}import{{end_b}}
      scope: support.function.directive.nasm
      push:
        - match: '{{valid_identifier}}'
          scope: entity.name.function.nasm
          set:
            - match: '{{valid_identifier}}'
              scope: meta.path.nasm string.unquoted.nasm
              set:
                - match: '{{valid_identifier}}'
                  scope: variable.function.nasm
                  set:
                    - include: single-line-comments-pop
                    - match: '{{valid_identifier}}'
                      scope: invalid.illegal.nasm
                    - include: whitespace
                    - include: pop-if-not-whitespace
                - include: whitespace
                - include: pop-if-not-whitespace
            - include: whitespace
            - include: pop-if-not-whitespace
        - include: whitespace
        - include: pop-if-not-whitespace
    - match: (?i){{stt_b}}export{{end_b}}
      scope: support.function.directive.nasm
      push:
        - match: '{{valid_identifier}}'
          scope: entity.name.constant.nasm
          set:
            - match: '{{valid_identifier}}'
              scope: variable.function.nasm
              set:
                - match: =
                  scope: keyword.operator.assignment.nasm
                - match: (?i){{stt_b}}(?:resident|nodata){{end_b}}
                  scope: storage.modifier.directive.nasm variable.parameter.directive.nasm
                - match: (?i){{stt_b}}parm{{end_b}}
                  scope: variable.parameter.directive.nasm
                - include: whitespace
                - include: main
            - include: whitespace
            - include: pop-if-not-whitespace
        - include: whitespace
        - include: pop-if-not-whitespace
    - match: (?i){{stt_b}}global{{end_b}}
      scope: support.function.directive.nasm
      push:
        - match: (?i)(:)(function|data|export){{end_b}}
          captures:
            1: keyword.control.nasm # just for purple color
            2: storage.type.directive.nasm
        - match: (?i){{stt_b}}(?:default|internal|hidden|protected|proc|data){{end_b}}
          scope: storage.modifier.directive.nasm
        - include: whitespace
        # TODO: I don't know why macro parameters were included in `extern`, `export`, etc.
        # - include: preprocessor-macro-parameter
        - include: main
    - match: (?i){{stt_b}}(?:extern|required){{end_b}}
      scope: support.function.directive.nasm
      push:
        - match: (?i)(:)(import){{end_b}}
          captures:
            1: keyword.control.nasm # just for the purple color. (but no italics)
            2: storage.type.directive.nasm
        - match: (?i){{stt_b}}(?:proc|data){{end_b}}
          scope: storage.modifier.directive.nasm
        - include: whitespace
        # - include: preprocessor-macro-parameter
        - include: main
    - match: (?i){{stt_b}}library{{end_b}}
      scope: support.function.directive.nasm
      push:
        - match: '{{valid_identifier}}'
          scope: meta.path.nasm string.unquoted.nasm
          pop: true
        - include: whitespace
        - include: pop-if-not-whitespace
    - match: (?i){{stt_b}}module{{end_b}}
      scope: support.function.directive.nasm
      push:
        - match: \$?{{valid_identifier}}
          scope: entity.name.namespace.nasm
          pop: true
        - include: whitespace
        - include: pop-if-not-whitespace
    - match: (?i){{stt_b}}cpu{{end_b}}
      scope: support.function.directive.nasm
      push:
        # `https://github.com/netwide-assembler/nasm/blob/master/asm/directiv.c` `set_cpu()`.
        - match: (?i)(?:\s+|\b)([+*-]|no)?({{valid_cpu}}){{end_b}}
          captures:
            1: keyword.operator.logical.flag.nasm
            2: support.constant.directive.nasm
          set:
            - match: (?i)\s*(,)\s*([+*-]|no)?({{valid_cpu}}){{end_b}}
              captures:
                1: punctuation.separator.comma.nasm
                2: keyword.operator.logical.flag.nasm
                3: support.constant.flag.nasm
            - match: \S+
              scope: invalid.illegal.nasm
            - include: whitespace
        - match: \S+
          scope: invalid.illegal.nasm
        - include: whitespace
    - match: (?i){{stt_b}}float{{end_b}}
      scope: support.function.directive.nasm
      push:
        - match: (?i){{stt_b}}(?:daz|nodaz|near|up|down|zero|default){{end_b}}
          scope: support.constant.directive.nasm
          pop: true
        - include: whitespace
        - include: pop-if-not-whitespace
        - include: main
    - match: (?i){{stt_b}}alignmode{{end_b}}
      scope: support.function.nasm
      push:
        - include: whitespace
        - match: (?i){{stt_b}}(?:generic|nop|k[78]|p6){{end_b}}
          scope: support.constant.nasm
        - match: (?i){{stt_b}}nojmp{{end_b}}
          scope: support.constant.smartalign.nasm
        - match: '{{line_rem}}'
          scope: invalid.illegal.constant.nasm
  bracket-directives:
    # everything after `]` and up to a newline is ignored as of NASM 2.16.03.
    # this seems like it might be an implementation detail rather than a design choice.
    # TODO: If this ^^^^^ becomes not the case, replace applicable instances of
    # `set: comment-line-remainder` with `pop: true`.
    # also do the same for `directive-pragma` and `directive-pragma-unknown`.
    - match: (?i)^\s*(\[)\s*(warning){{end_b}}
      captures:
        1: meta.brackets.nasm punctuation.section.brackets.begin.nasm
        2: support.function.directive.nasm
      push:
        - match: (\+)\s*(error)\s*(?=\])
          captures:
            1: keyword.control.warning.nasm
            2: support.constant.directive.warning.nasm
        - match: ({{warning_class}})\s*(?=\])
          # i.e. [warning warning-class], without *, -, +, or error=.
          captures:
            1: support.constant.directive.warning.nasm
            2: meta.brackets.nasm punctuation.section.brackets.end.nasm
        - match: (?i)([+*-])?\s*(?:(error)\s*(=)\s*)|([+*-])(?!\s*\])
          # The `[+*-]` by itself has to be the second one it checks.
          captures:
            1: keyword.control.warning.nasm
            2: support.constant.directive.warning.nasm
            3: keyword.operator.assignment.nasm
            4: keyword.control.warning.nasm
          push:
            - match: '{{warning_class}}\s*(?=\])'
              scope: support.constant.directive.warning.nasm
              pop: true
            # slightly different than {{line_rem_bracketed}}
            - match: \S.+(?=\])
              scope: invalid.illegal.support.constant.directive.warning.nasm
              pop: true
            - match: \S.+
              scope: invalid.illegal.support.constant.directive.warning.nasm
              pop: true
        - match: (?i){{stt_b}}(error|push|pop)\s*(?=\])
          captures:
            1: support.constant.directive.warning.nasm
        - match: '{{line_rem_bracketed}}'
          scope: invalid.illegal.support.constant.directive.warning.nasm
        - match: \]
          scope: meta.brackets.nasm punctuation.section.brackets.end.nasm
          set: comment-line-remainder
        - include: whitespace
    - match: (?i)^\s*(\[)\s*(map){{end_b}}
      captures:
        1: meta.brackets.nasm punctuation.section.brackets.begin.nasm
        2: support.function.directive.nasm
      push:
        - match: (?i){{stt_b}}(?:all|brief|sections|segments|symbols){{end_b}}
          scope: support.constant.directive.map.nasm
        - match: (?i){{stt_b}}std(?:out|err){{end_b}}
          scope: meta.path.nasm support.constant.directive.map.nasm
        - match: '{{valid_identifier}}'
          scope: string.unquoted.map.file.nasm
        - match: \]
          scope: meta.brackets.nasm punctuation.section.brackets.end.nasm
          set: comment-line-remainder
        - include: whitespace
    - match: (?i)^\s*(\[)\s*(pragma){{end_b}}
      captures:
        1: meta.brackets.nasm punctuation.section.brackets.begin.nasm
        2: support.function.directive.nasm
      push: directive-pragma
  directive-pragma:
    # Any changes here must also be made to `preprocessor-pragma`
    # See preprocessor-pragma for any applicable comments.
    - match: (?i){{stt_b}}limit{{end_b}}
      scope: support.constant.pragma.facility.nasm
      set:
        - match: (?i){{stt_b}}(?:(?:stalled-)?passes|macro-(?:levels|tokens)|mmacros|rep|eval|lines)(?!-){{end_b}}
          scope: support.constant.pragma.opname.nasm
          set:
            - match: (?i){{stt_b}}unlimited{{end_b}}
              scope: entity.name.tag.pragma.arg.nasm
              set: directive-pragma-unknown
            - match: '{{stt_b}}\d+{{end_b}}'
              scope: constant.numeric.value.pragma.limit.nasm
              set: directive-pragma-unknown
            - include: directive-pragma-unknown
        - include: directive-pragma-unknown
    - match: (?i){{stt_b}}list{{end_b}}
      scope: support.constant.pragma.facility.nasm
      set:
        - match: (?i){{stt_b}}options{{end_b}}
          scope: support.constant.pragma.opname.nasm
          set:
            - match: (?i)([+-])[a-z]*{{end_b}}
              scope: entity.name.tag.nasm
              captures:
                1: markup.italic.nasm
              set: directive-pragma-unknown
            - include: directive-pragma-unknown
        - include: directive-pragma-unknown
    - match: (?i){{stt_b}}preproc{{end_b}}
      scope: invalid.illegal.pragma-preproc-directive.nasm
      set:
        # basically `set: directive-pragma-unknown`, but with different scopes.
        - include: line-continuation
        - match: \]
          scope: meta.brackets.nasm punctuation.section.brackets.end.nasm
          set: comment-line-remainder
        - match: $\n
          # newline without a closing bracket.
          scope: invalid.illegal.nasm
          set: comment-line-remainder
        - match: '{{line_rem_bracketed}}'
          scope: invalid.illegal.nasm
    - match: (?i){{stt_b}}ignore{{end_b}}
      scope: support.constant.pragma.facility.nasm
      set:
        - meta_content_scope: comment.line.nasm
        - match: (?=\])
          set: directive-pragma-unknown
        - include: whitespace

    # outputs
    - match: (?i){{stt_b}}obj{{end_b}}
      scope: support.constant.pragma.facility.nasm
      set:
        - match: (?i){{stt_b}}nodepend{{end_b}}
          scope: support.constant.pragma.opname.nasm
          set: directive-pragma-unknown
        - include: directive-pragma-unknown
    - match: (?i){{stt_b}}dbg{{end_b}}
      scope: support.constant.pragma.facility.nasm
      set:
        - match: (?i){{stt_b}}maxdump{{end_b}}
          scope: support.constant.pragma.opname.nasm
          set:
            - match: (?i){{stt_b}}unlimited{{end_b}}
              scope: entity.name.tag.pragma.arg.nasm
              set: directive-pragma-unknown
            - match: '{{stt_b}}\d+{{end_b}}'
              scope: constant.numeric.value.pragma.dbg.nasm
              set: directive-pragma-unknown
            - include: directive-pragma-unknown
        - match: (?i){{stt_b}}noseclabels{{end_b}}
          scope: support.constant.pragma.opname.nasm
          set:
            - match: (?i){{stt_b}}(?:true|false|yes|no|on|off){{end_b}}
              scope: entity.name.tag.pragma.arg.nasm
              set: directive-pragma-unknown
            - include: directive-pragma-unknown
        - include: directive-pragma-unknown
    - match: (?i){{stt_b}}macho(?:32|64)?{{end_b}}
      scope: support.constant.pragma.facility.nasm
      set:
        - match: (?i){{stt_b}}subsections_via_symbols{{end_b}}
          scope: support.constant.pragma.opname.nasm
          set: directive-pragma-unknown
        - match: (?i){{stt_b}}(?:no_dead_strip|[gl]?(pre|suf)fix){{end_b}}
          scope: support.constant.pragma.opname.nasm
          set:
            - match: '[^\s;\]]+'
              scope: entity.name.tag.pragma.arg.nasm
              set: directive-pragma-unknown
            - include: directive-pragma-unknown
        - include: directive-pragma-unknown
    - match: (?i){{stt_b}}(?:output|(?:win|elf)(?:32|64)?|elfx32){{end_b}}
      scope: support.constant.pragma.facility.nasm
      set:
        - match: (?i){{stt_b}}[gl]?(?:pre|suf)fix{{end_b}}
          scope: support.constant.pragma.opname.nasm
          set:
            - match: '[^\s;\]]+'
              scope: entity.name.tag.pragma.arg.nasm
              set: directive-pragma-unknown
            - include: directive-pragma-unknown
        - include: directive-pragma-unknown

    # everything left
    - match: (?i){{stt_b}}(?:asm|debug|file|ignore|input){{end_b}}
      scope: support.constant.pragma.facility.nasm
      set: directive-pragma-unknown

    - include: directive-pragma-unknown
  directive-pragma-unknown:
    - include: line-continuation
    - match: \]
      scope: meta.brackets.nasm punctuation.section.brackets.end.nasm
      set: comment-line-remainder
    - match: $\n
      # newline without a closing bracket.
      scope: invalid.illegal.nasm
      set: comment-line-remainder
    - match: '{{line_rem_bracketed}}'
      scope: entity.name.tag.pragma.unknown.nasm markup.underline.nasm
  section-parameters:
    # everything unknown is left without a scope.
    - match: =
      scope: keyword.operator.assignment.nasm
    - match: (?i){{stt_b}}(?:v?start|align|absolute){{end_b}}
      scope: storage.modifier.segment.nasm
    - match: (?i){{stt_b}}(?:(?:prog|no)bits|private|public|common|stack|code|text|data|bss|rdata|info){{end_b}}
      scope: storage.modifier.segment.nasm
    - match: (?i){{stt_b}}(?:mixed|zerofill|no_dead_strip|live_support|strip_static_syms){{end_b}}
      scope: storage.modifier.segment.nasm
    - match: (?i){{stt_b}}(?:(?:no)?(?:alloc|exec|write)|tls){{end_b}}
      scope: storage.modifier.segment.nasm
    - match: (?i){{stt_b}}v?follows{{end_b}}
      scope: storage.modifier.segment.nasm
      push:
        - match: =
          scope: keyword.operator.assignment.nasm
          set: [pop, section-name]
        - include: whitespace
    - match: (?i){{stt_b}}(?:class|overlay){{end_b}}
      scope: storage.modifier.segment.nasm
      push:
        - match: =
          scope: keyword.operator.assignment.nasm
        - match: '{{valid_identifier}}'
          scope: entity.name.class.nasm string.unquoted.nasm
          pop: true
        - include: whitespace
    - include: whitespace
    - include: main
  section-name:
    # TODO: are segment names case sensitive?
    # TODO: I remember something like `section bss` doesn't work without the `.`
    - match: (?:\.|{{stt_b}})(?:[lt]?bss|(?:[lprtx]|l?ro)?data|(?:init|preinit|fini)_array|code|text|debug_abbrev|comment|note){{end_b}}
      scope: support.constant.section.nasm
      pop: true
    - match: (?i){{stt_b}}__(?:bss|const|data|text)(?:(,)\s*__(?:bss|const|data|text))?{{end_b}}
      scope: support.constant.section.macho.nasm
      captures:
        1: punctuation.separator.nasm
      pop: true
    - match: (?:\.|{{stt_b}}){{valid_identifier}}{{end_b}}
      scope: entity.name.section.nasm string.unquoted.nasm
      pop: true
    - match: (?=[`'"])
      set:
        - meta_scope: entity.name.section.nasm
        - include: strings
        - include: pop
    - include: whitespace
    - include: pop-if-not-whitespace
  structs:
    - match: (?i){{stt_b}}struc{{end_b}}
      scope: support.function.nasm meta.struct.nasm
      push:
        - meta_content_scope: meta.struct.nasm
        - match: '{{valid_identifier}}'
          scope: entity.name.struct.nasm
          set:
            - meta_scope: meta.struct.nasm
            - match: (?i){{stt_b}}endstruc{{end_b}}
              scope: support.function.nasm meta.struct.nasm
              pop: true
            - include: main
        # TODO: wtf is this for? same question for the istruc one.
        - match: \w
          scope: invalid.illegal.entity.name.struct.nasm
    - match: (?i){{stt_b}}endstruc{{end_b}}
      scope: invalid.illegal.support.function.nasm meta.struct.nasm
    - match: (?i){{stt_b}}istruc{{end_b}}
      scope: support.function.nasm meta.struct.nasm
      push:
        - meta_content_scope: meta.struct.nasm
        - match: '{{valid_identifier}}'
          scope: variable.other.nasm
          set:
            - meta_scope: meta.struct.nasm
            - match: (?i){{stt_b}}at{{end_b}}
              scope: support.function.nasm meta.struct.nasm
            - match: (?i){{stt_b}}iend{{end_b}}
              scope: support.function.nasm meta.struct.nasm
              pop: true
            - include: main
        - match: \w
          scope: invalid.illegal.variable.struct.nasm
    - match: (?i){{stt_b}}iend{{end_b}}
      scope: invalid.illegal.support.function.nasm meta.struct.nasm
    # TODO: move these to `directives`?
    - match: (?i){{stt_b}}alignb?{{end_b}}
      scope: support.function.nasm
    - match: (?i){{stt_b}}(sectalign)\b\s*(on|off)?{{end_b}}
      captures:
        1: support.function.nasm
        2: entity.name.tag.nasm
  data-types:
    # Initialized & uninitialized data: https://www.nasm.us/doc/nasmdoc3.html#section-3.2.1
    # `tbyte` is defined after `%use masm` as an alias to `tword`.
    # `long` is an alias of `dword`.
    - match: (?i){{stt_b}}(?:t?byte|[dqtoyz]?word|(?:d|res)[bwdqtoyz]|long){{end_b}}
      scope: storage.type.nasm
    - match: (?i){{stt_b}}(?:incbin|equ|times|dup){{end_b}}
      scope: support.function.nasm
  prefixes:
    - match: (?i){{stt_b}}(?:strict|nosplit|abs|rel|near|far|short|to){{end_b}}
      # I don't know if `to` is actually a prefix.
      # but `fadd to st0` is a valid instruction,
      # which functions in a similar-looking way to `jmp short label`.
      scope: storage.modifier.nasm
    - match: (?i){{stt_b}}(?:[ao](?:16|32|64|sp)){{end_b}}
      scope: storage.modifier.prefix.nasm
    - match: (?i){{stt_b}}(?:rep(?:n?[ez])?|lock|bnd|nobnd){{end_b}}
      scope: storage.modifier.prefix.nasm
    - match: (?i){{stt_b}}x(?:acquire|release){{end_b}}
      # MPX removed in 2019
      scope: invalid.deprecated.memory-protection.nasm
    - match: (?i){(vex[23]?|evex|rex)(\s*)}
      captures:
        1: storage.modifier.prefix.nasm
        2: invalid.deprecated.nasm
  decorators:
    # Whitespace is allowed on the right side of decorators as of NASM 2.16.03.
    # This seems more like implementation detail than a deliberate design choice.
    # so this is probably subject to change.
    - match: (?i){(k[1-7])(\s*)}
      captures:
        1: storage.modifier.opmask.nasm
        2: invalid.deprecated.nasm
    - match: (?i){(1to(?:2|4|8|16|32))(\s*)}
      captures:
        1: storage.modifier.broadcasting.nasm
        2: invalid.deprecated.nasm
    - match: (?i){(z|(?:r[nduz]-)?sae)(\s*)}
      # round [nearest, down, up, towards zero]
      # suppress all exceptions.
      captures:
        1: storage.modifier.rounding.nasm
        2: invalid.deprecated.nasm
  entities:
    - match: \$@feat\.00{{end_b}}
      scope: variable.language.sseh.nasm
    # - match: (\$)\w+{{end_b}}
    #   scope: variable.other.nasm
    #   captures:
    #     1: punctuation.definition.variable.nasm
    # TODO: fix $ when it is right before a valid identifier.
    # i.e. $asdf
    - match: \${3,}
      scope: invalid.illegal.variable.language.nasm
    - match: \$
      scope: variable.language.nasm
  support:
    # predefined macros and constants and stuff
    - match: '{{stt_b}}\.\.(?:got(?:pc(?:rel)?|(?:tp)?off)?|imagebase|start|tlvp|plt|sym|tlsie){{end_b}}'
      scope: support.constant.nasm
    - match: (?i){{stt_b}}__(\??)(?:utf(?:16|32)(?:[lb]e)?|infinity|[qs]?nan|masm_(?:ptr|flat))\1__{{end_b}}
      scope: support.constant.nasm

    - match: '{{stt_b}}(?:__NASMDEFSEG|_GLOBAL_OFFSET_TABLE_){{end_b}}'
      scope: support.constant.nasm
    - match: '{{stt_b}}__(\??)NASM_(?:MAJOR|(?:SUB)?MINOR|SNAPSHOT|VER(?:SION_ID)?|PATCHLEVEL)\1__{{end_b}}'
      scope: support.constant.nasm
    - match: '{{stt_b}}__(\??)(?:FILE|LINE|SECT|BITS|(?:OUTPUT|DEBUG)_FORMAT|PTR|FLOAT(?:_ROUND|_DAZ)?|(?:UTC_)?(?:DATE|TIME)(?:_NUM)?|POSIX_TIME|(?:(?:USE|ALIGN)_[A-Z]+)|SECTALIGN_ALIGN_UPDATES_SECTION|ALIGNMODE)\1__{{end_b}}'
      scope: support.constant.nasm
    - match: '{{stt_b}}(?:Inf|[QS]?NaN){{end_b}}'
      scope: support.constant.fp.nasm

    - match: '{{stt_b}}__(\??)PASS\1__{{end_b}}'
      scope: invalid.deprecated.support.constant.nasm

    - match: (?i){{stt_b}}__(\??)(?:b?float16|float(?:8|32|64|80[me]|128[lh]))\1__{{end_b}}
      scope: support.function.nasm
    - match: '{{stt_b}}(?:bfloat16|float(?:8|16|32|64|80[em]|128[lh])){{end_b}}'
      scope: support.function.nasm
    - match: (?i){{stt_b}}__(\??)ilog2(?:[cefw]|[cf]w)?\1__{{end_b}}
      scope: support.function.ifunc.nasm
    - match: (?i){{stt_b}}ilog2(?:[cefw]|[cf]w)?{{end_b}}
      scope: support.function.ifunc.nasm
  # TODO: labels are broken. restore them to a fixed version, and re-update them later.
  # `labels` also includes calls to macro functions.
  labels:
    # https://www.nasm.us/doc/nasmdoc3.html#section-3.9
    - match: (\.\.@)({{valid_identifier}})(?:(:?)|\b)
      captures:
        1: storage.modifier.nasm
        2: entity.name.constant.special.nasm
        3: punctuation.separator.nasm
    - match: \b({{valid_identifier}})(?:(:?)|\b)
      captures:
        1: entity.name.constant.nasm
        2: punctuation.separator.nasm
    - match: (\.)(\d?{{identifier_body}})(?:(:?)|\b)
      captures:
        1: storage.modifier.nasm
        2: entity.name.constant.nasm
        3: punctuation.separator.nasm
    - match: (\.)([\d$@~]{{identifier_body}})(?:(:?)|\b)
      captures:
        1: punctuation.separator.nasm storage.modifier.nasm
        2: invalid.illegal.entity.name.constant.nasm
        3: punctuation.separator.nasm
    - match: (%)(\d+)
      scope: invalid.illegal.meta.preprocessor.nasm
      captures:
        1: punctuation.definition.variable.preprocessor.nasm keyword.control.preprocessor.nasm
        2: variable.other.preprocessor.nasm
    - match: (%%)({{valid_identifier}})(?:(:?)|\b)
      scope: invalid.illegal.meta.preprocessor.nasm
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm keyword.control.preprocessor.nasm
        2: entity.name.constant.special.nasm
        3: punctuation.separator.nasm
  label-reference:
    # TODO: use `label-reference` places
    # https://www.nasm.us/doc/nasmdoc3.html#section-3.9
    - match: (\.\.@)({{valid_identifier}})\b
      captures:
        1: punctuation.separator.nasm storage.modifier.nasm
        2: entity.name.constant.special.nasm
    - match: (\.?|\b)({{valid_identifier}})\b
      captures:
        1: punctuation.separator.nasm storage.modifier.nasm
        2: entity.name.constant.nasm
    - match: (\.)(\d+{{identifier_body}})\b
      captures:
        1: punctuation.separator.nasm storage.modifier.nasm
        2: entity.name.constant.nasm
    - match: (?:(\.)?|\b)([\d$@~]{{identifier_body}})\b
      captures:
        1: punctuation.separator.nasm storage.modifier.nasm
        2: invalid.illegal.entity.name.constant.nasm
    - match: (%)(\d+)
      scope: invalid.illegal.meta.preprocessor.nasm
      captures:
        1: punctuation.definition.variable.preprocessor.nasm keyword.control.preprocessor.nasm
        2: variable.other.preprocessor.nasm
    - match: (%%)({{valid_identifier}})\b
      scope: invalid.illegal.meta.preprocessor.nasm
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm keyword.control.preprocessor.nasm
        2: entity.name.constant.special.nasm
        3: punctuation.separator.nasm

  comment-line-remainder:
    # the rest of the line after `;`. allows line continuations
    - meta_content_scope: comment.line.nasm
    - include: whitespace
  single-line-comments-cont:
    # continues the current context after the comment.
    # use everywhere that the `pop` version doesn't make sense.
    - match: ;
      scope: punctuation.definition.comment.nasm
      push: comment-line-remainder
  single-line-comments-pop:
    # pops from the current context after the comment.
    # use in contexts where there can't be more stuff in the scope after the comment.
    # i.e. preprocessor directives.
    - match: ;
      scope: punctuation.definition.comment.nasm
      set: comment-line-remainder
  block-comment-false-nested-conditions:
    # the block after `%if 0`
    - meta_content_scope: comment.block.nasm
    - match: (?i)^\s*%{{if_directive}}{{end_b}}
      push: block-comment-false-nested-conditions
    - match: (?i)^\s*%endif{{end_b}}
      pop: true
  block-comment-true-nested-conditions:
    # the block after `%if 1`
    - match: (?i)^\s*(%)(else|el{{if_directive}}){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
      set:
        - meta_content_scope: comment.block.nasm
        - match: (?i)^\s*(%)(endif){{end_b}}
          captures:
            1: punctuation.definition.keyword.preprocessor.nasm
            2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
          pop: true
        - include: block-comment-false-nested-conditions
    - match: (?i)^\s*(%)(endif){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
      pop: true

    - include: main
  comments:
    # these also apply to `macro-comments`:
    # TODO: make `%rep 0` highlight as a comment block.
    # TODO: ifn?difi is a comment even in the elif/else branches.
      # this requires a separate match and context from this one.
    - include: single-line-comments-cont
    # TODO: `%if 0\` doesn't highlight as a comment block
    - match: (?i)^\s*(%)(?:(if)\s+({{zero}})\s*(;.*)?$\n?|(ifn?difi){{end_b}})
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
        3: constant.numeric.nasm
        4: punctuation.definition.comment.nasm
        5: meta.preprocessor.nasm keyword.control.preprocessor.nasm
      push:
        - meta_content_scope: comment.block.nasm
        - match: (?i)^\s*%{{if_directive}}{{end_b}}
          push: block-comment-false-nested-conditions
        - match: (?i)^\s*(%)(endif){{end_b}}
          captures:
            1: punctuation.definition.keyword.preprocessor.nasm
            2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
          pop: true
        - match: (?i)^\s*(%)(else|el{{if_directive}}){{end_b}}
          captures:
            1: punctuation.definition.keyword.preprocessor.nasm
            2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
          set: preprocessor-conditions-content-block
    - match: (?i)^\s*(%)(?:(if)\s+({{nonzero}})\s*$\n?)
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
        3: constant.numeric.nasm
      push: block-comment-true-nested-conditions
  macro-block-comment-false-nested-conditions:
    # the block after `%if 0` (inside a macro)
    - meta_content_scope: comment.block.nasm
    - match: (?i)^\s*%{{if_directive}}{{end_b}}
      push: macro-block-comment-false-nested-conditions
    - match: (?i)^\s*%endif{{end_b}}
      pop: true
  macro-block-comment-true-nested-conditions:
    # the block after `%if 1` (inside a macro)
    - match: (?i)^\s*(%)(else|el{{if_directive}}){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
      set:
        - meta_content_scope: comment.block.nasm
        - match: (?i)^\s*(%)(endif){{end_b}}
          captures:
            1: punctuation.definition.keyword.preprocessor.nasm
            2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
          pop: true
        - include: macro-block-comment-false-nested-conditions
    - match: (?i)^\s*(%)(endif){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
      pop: true
    - include: preprocessor-macro-main
  macro-comments:
    - include: single-line-comments-cont
    - match: (?i)^\s*(%)(?:(if)\s+({{zero}})\s*$\n|(ifn?difi){{end_b}})
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
        3: constant.numeric.nasm
        4: meta.preprocessor.nasm keyword.control.preprocessor.nasm
      push:
        - meta_content_scope: comment.block.nasm
        - match: (?i)^\s*%{{if_directive}}{{end_b}}
          push: macro-block-comment-false-nested-conditions
        - match: (?i)^\s*(%)(endif){{end_b}}
          captures:
            1: punctuation.definition.keyword.preprocessor.nasm
            2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
          pop: true
        - match: (?i)^\s*(%)(else|el{{if_directive}}){{end_b}}
          captures:
            1: punctuation.definition.keyword.preprocessor.nasm
            2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
          set: preprocessor-macro-conditions-content-block
    - match: (?i)^\s*(%)(?:(if)\s+({{nonzero}})\s*$\n)
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
        3: constant.numeric.nasm
      push: macro-block-comment-true-nested-conditions

  # `macro` means `%macro` unless it explicitly says single-line.
  preprocessor:
    # https://www.nasm.us/doc/nasmdoc4.html
    - include: preprocessor-macro
    - include: preprocessor-single-line-macro
    - include: preprocessor-special-tokens
    - include: preprocessor-conditions
    - include: preprocessor-undefine
    - include: preprocessor-functions
  preprocessor-indirection:
    - match: (%)(\[)
      scope: meta.preprocessor.macro.nasm keyword.control.preprocessor.nasm
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.brackets.nasm punctuation.section.brackets.begin.nasm
      push:
        - meta_scope: meta.brackets.nasm meta.preprocessor.macro.nasm
        - include: whitespace
        - include: main
        - match: \]
          scope: punctuation.section.brackets.end.nasm
          pop: true
  preprocessor-special-tokens:
    - include: preprocessor-indirection
    - match: (%)(\+)\s+
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.operator.preprocessor.nasm
    - match: (%)(\*?\?\??)
      scope: meta.preprocessor.nasm keyword.operator.preprocessor.nasm
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: variable.language.preprocessor.nasm
    - match: (%)(,)
      scope: meta.preprocessor.nasm keyword.operator.preprocessor.nasm
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: punctuation.separator.sequence.conditional-comma.nasm
    - match: (%\$+)({{valid_identifier}})(?:(:)?|{{end_b}})
      scope: meta.preprocessor.nasm
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm keyword.control.preprocessor.nasm
        2: entity.name.constant.special.nasm
        3: punctuation.separator.nasm
    - match: (%)(\!)
      scope: meta.preprocessor.nasm keyword.operator.preprocessor.nasm
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: punctuation.definition.variable.nasm
      push:
        - meta_content_scope: meta.preprocessor.nasm keyword.operator.preprocessor.nasm variable.parameter.preprocessor.environment.nasm
        - match: '{{valid_identifier}}'
          scope: variable.parameter.preprocessor.environment.unquoted.nasm
          pop: true
        - match: (?=[`'"])
          set:
            - meta_scope: variable.parameter.preprocessor.environment.quoted.nasm
            - include: strings
            - include: pop
        - include: pop
  preprocessor-undefine:
    - include: preprocessor-special-tokens
    - match: (?i)^\s*(%)(undef(?:alias)?){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
      push:
        - meta_scope: meta.preprocessor.nasm
        - match: (?:(?<=%undef)|(?<=%undefalias))[^\S\n]+
          # only ignore space at the start
          # Technically this also allows this: `%undef asdf%undef qwer`.
          # `qwer` should highlight as invalid, but doesn't.
        - include: line-ending
        - include: line-continuation
        - match: '{{valid_identifier}}(?=%\[)'
          scope: entity.name.constant.preprocessor.nasm
        - include: preprocessor-indirection
        - match: '{{valid_identifier}}'
          scope: entity.name.constant.preprocessor.nasm
        - match: \s|([^\w#$.?@~])
          captures:
            1: invalid.illegal.nasm
          set:
            - match: '{{line_rem}}'
              scope: invalid.illegal.nasm
            - include: whitespace
    - match: (?i)^\s*(%)(uni?macro){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.import.nasm
      push: preprocessor-macro-param-signature
  preprocessor-functions:
    # TODO: %cond(condition, %directive, %directive).
      # if `%cond` is the first thing on a line, then in both branches,
      # if the first thing is a valid directive, it should highlight as such.
      # For simplicity, always allow things like `%elif`, `%endrep`, etc.,
      # but don't pop the context, because that is too hard.
    - match: (?i)(%)(isn?difi)\s*(\()
      # %ifdifi, and by extension %isdifi, ignores its argument and returns 0.
      # %ifndifi does the same thing.
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: support.function.preprocessor.nasm
        3: meta.brackets.nasm punctuation.macro.arguments.brackets.begin.nasm
      push:
        - include: line-continuation
        - match: $\n
          scope: invalid.illegal.nasm
        - meta_content_scope: comment.block.nasm
        - match: \)
          scope: meta.brackets.nasm punctuation.macro.arguments.brackets.end.nasm
          pop: true
    - match: (?i)(%)(abs|cond|count|eval|hex|is{{valid_condition}}|map|num|sel|str(?:cat|len)?|substr|tok)\s*(\()
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: support.function.preprocessor.nasm
        3: meta.brackets.nasm punctuation.macro.arguments.brackets.begin.nasm
      push:
        - include: line-continuation
        - match: $\n
          scope: invalid.illegal.nasm
        - match: \,
          scope: punctuation.separator.sequence.nasm
        - match: \)
          scope: meta.brackets.nasm punctuation.macro.arguments.brackets.end.nasm
          pop: true
        # TODO: make both `%eval(%1)` and `%eval(__BITS__)` have correct highlighting.
        # having `main` first breaks `%1`, and having `main` after breaks `__BITS__`.
        - include: preprocessor-conditions-constant
        - include: main
  preprocessor-pragma:
    # use `https://github.com/netwide-assembler/nasm/blob/master/asm/directiv.dat` for the official list of valid pragma facilities
    # push this context right after `%pragma`
    - match: (?i){{stt_b}}limit{{end_b}}
      scope: support.constant.pragma.facility.nasm
      set:
        - match: (?i){{stt_b}}(?<!-)(?:(?:stalled-)?passes|macro-(?:levels|tokens)|mmacros|rep|eval|lines)(?!-){{end_b}}
          scope: support.constant.pragma.opname.nasm
          set:
            - match: (?i){{stt_b}}unlimited{{end_b}}
              scope: entity.name.tag.pragma.arg.nasm
              set: preprocessor-pragma-unknown
            - match: '{{stt_b}}\d+{{end_b}}'
              scope: constant.numeric.value.pragma.limit.nasm
              set: preprocessor-pragma-unknown
            - include: preprocessor-pragma-unknown
        - include: preprocessor-pragma-unknown
    - match: (?i){{stt_b}}list{{end_b}}
      scope: support.constant.pragma.facility.nasm
      set:
        - match: (?i){{stt_b}}options{{end_b}}
          scope: support.constant.pragma.opname.nasm
          set:
            # only `[bdefmpsw]` are available now. the rest are ignored for future compatabiloty.
            - match: (?i)([+\-])[a-z]*{{end_b}}
              scope: entity.name.tag.nasm
              captures:
                1: markup.italic.nasm
              set: preprocessor-pragma-unknown
            - include: preprocessor-pragma-unknown
        - include: preprocessor-pragma-unknown
    - match: (?i){{stt_b}}preproc{{end_b}}
      scope: support.constant.pragma.facility.nasm
      set:
        - match: (?i){{stt_b}}sane_empty_expansion{{end_b}}
          scope: support.constant.pragma.opname.nasm
          set:
            - match: (?i){{stt_b}}(?:true|false|yes|no|on|off){{end_b}}
              scope: entity.name.tag.pragma.arg.nasm
              set: preprocessor-pragma-unknown
            - include: preprocessor-pragma-unknown
        - include: preprocessor-pragma-unknown
    - match: (?i){{stt_b}}ignore{{end_b}}
      scope: support.constant.pragma.facility.nasm
      set:
        # `%pragma ignore` is ignored.
        - meta_content_scope: comment.line.nasm
        - include: whitespace

    # outputs
    - match: (?i){{stt_b}}obj{{end_b}}
      scope: support.constant.pragma.facility.nasm
      set:
        - match: (?i){{stt_b}}nodepend{{end_b}}
          scope: support.constant.pragma.opname.nasm
          set: preprocessor-pragma-unknown
        - include: preprocessor-pragma-unknown
    - match: (?i){{stt_b}}dbg{{end_b}}
      scope: support.constant.pragma.facility.nasm
      set:
        - match: (?i){{stt_b}}maxdump{{end_b}}
          scope: support.constant.pragma.opname.nasm
          set:
            - match: (?i){{stt_b}}unlimited{{end_b}}
              scope: entity.name.tag.pragma.arg.nasm
              set: preprocessor-pragma-unknown
            - match: '{{stt_b}}\d+{{end_b}}'
              scope: constant.numeric.value.pragma.dbg.nasm
              set: preprocessor-pragma-unknown
            - include: preprocessor-pragma-unknown
        - match: (?i){{stt_b}}noseclabels{{end_b}}
          scope: support.constant.pragma.opname.nasm
          set:
            - match: (?i){{stt_b}}(?:true|false|yes|no|on|off){{end_b}}
              scope: entity.name.tag.pragma.arg.nasm
              set: preprocessor-pragma-unknown
            - include: preprocessor-pragma-unknown
        - include: preprocessor-pragma-unknown
    - match: (?i){{stt_b}}macho(?:32|64)?{{end_b}}
      scope: support.constant.pragma.facility.nasm
      set:
        - match: (?i){{stt_b}}subsections_via_symbols{{end_b}}
          scope: support.constant.pragma.opname.nasm
          set: preprocessor-pragma-unknown
        - match: (?i){{stt_b}}(?:no_dead_strip|[gl]?(pre|suf)fix){{end_b}}
          scope: support.constant.pragma.opname.nasm
          set:
            - match: '[^\s;]+'
              scope: entity.name.tag.pragma.arg.nasm
              set: preprocessor-pragma-unknown
            - include: preprocessor-pragma-unknown
        - include: preprocessor-pragma-unknown
    - match: (?i){{stt_b}}(?:(?:win|elf)(?:32|64)?|elfx32|output){{end_b}}
      scope: support.constant.pragma.facility.nasm
      set:
        # postfix is not a thing even though the docs say it is.
        - match: (?i){{stt_b}}[gl]?(?:pre|suf)fix{{end_b}}
          scope: support.constant.pragma.opname.nasm
          set:
            - match: '[^\s;]+'
              scope: entity.name.tag.pragma.arg.nasm
              set: preprocessor-pragma-unknown
            - include: preprocessor-pragma-unknown
        - include: preprocessor-pragma-unknown

    # everything left
    - match: (?i){{stt_b}}(?:asm|debug|file|ignore|input){{end_b}}
      scope: support.constant.pragma.facility.nasm
      set: preprocessor-pragma-unknown

    - include: preprocessor-pragma-unknown
  preprocessor-pragma-unknown:
    # not a very good name, but it handles 4 things.
      # 1. single-line comments
      # 2. line continuations
      # 3. line endings
      # 4. unknown pragma things, i.e. `%pragma limit asdfqwer`
    - include: single-line-comments-pop
    - include: whitespace
    - match: '{{line_rem}}'
      # unknown pragma. not an error for future compatability (NASM says so).
      # underlined to indicate it is unknown.
      # TODO: in some cases, an argument might be given this scope. that is a bug.
      scope: entity.name.tag.pragma.unknown.nasm markup.underline.nasm
  preprocessor-single-line-macro:
    - match: (?i)^\s*(%)((?:ix?|xi?)?define){{end_b}}
      # TODO: `%xidefine` may or may not actually exist.
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.macro.nasm keyword.control.import.preprocessor.nasm
      push:
        - meta_content_scope: meta.preprocessor.macro.nasm
        - match: (?:{{valid_identifier}})(?=\()
          scope: entity.name.function.preprocessor.nasm
          set:
            - match: \(
              scope: punctuation.section.group.begin.nasm
              set: preprocessor-single-line-macro-params
        # this include has to be between these other checks, or it will not work.
        - include: preprocessor-conditions-constant
        - match: '{{valid_identifier}}'
          scope: entity.name.constant.preprocessor.nasm
          set: preprocessor-single-line-macro-definition
        - include: whitespace
        - include: pop-if-not-whitespace
    - match: (?i)^\s*(%)(i?defalias){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.macro.nasm keyword.control.import.preprocessor.nasm
      push:
        - include: whitespace
        - include: preprocessor-macro-param-signature
    - match: (?i)^\s*(%)(i?(?:assign|deftok|strcat|strlen|substr|pathsearch)|push|pop|repl|line){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
      push:
        - meta_content_scope: meta.preprocessor.macro.nasm
        - include: preprocessor-special-tokens
        - include: preprocessor-conditions-constant
    - match: (?i)^\s*(%)(i?defstr)\b\s*(?:(%%)?({{valid_identifier}}))?{{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.macro.nasm keyword.control.import.preprocessor.assignment.nasm
        3: punctuation.definition.keyword.preprocessor.nasm keyword.control.preprocessor.nasm
        4: entity.name.constant.preprocessor.nasm
      push:
        - meta_content_scope: meta.preprocessor.macro.nasm string.unquoted.nasm
        - include: preprocessor-special-tokens
        - include: line-ending
    - match: (?i)^#
      # `# line-number file` gets transformed to a `%line` directive.
      # but only if it is the first character on a line.
      scope: punctuation.definition.annotation.nasm
    - match: (?<=\s)(#)
      scope: invalid.illegal.nasm
      push:
        - meta_content_scope: invalid.illegal.nasm
        - include: whitespace
    - match: (?i)^\s*(%)(include|require|depend){{end_b}}
      # %include is like C's `#include`, but `%require` is like `#include` with `#pragma once`.
      # TODO: `%include` resolves macros. Idk about the other two, but probably.
      # Probably wait until this gets added to `warning|error|fatal` to add it here.
      # TODO: figure out what this previous line is talking about.
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.import.preprocessor.nasm
      push: preprocessor-single-line-macro-definition
    - match: (?i)^\s*(%)(use){{end_b}}
      # TODO: update highlighting for `%use`. i.e. `%use masm`
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.import.preprocessor.nasm
      push:
        - match: (['"`]?)(?:altreg|fp|ifunc|masm|smartalign)\1[^\S\n]*(?=$)
          scope: support.constant.macro.nasm
          # scope: support.function.nasm
        - include: line-continuation
        - include: line-ending
        - match: '{{line_rem}}'
          scope: invalid.illegal.nasm
    - match: (?i)^\s*(%)(warning|error|fatal){{end_b}}
      # TODO: allow `%[]`, `%$varname`, `%eval(...)`, etc.
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.macro.nasm keyword.control.preprocessor.error.nasm
      push:
        - meta_content_scope: meta.preprocessor.macro.nasm string.unquoted.nasm
        - include: strings
        - include: preprocessor-special-tokens
        - include: line-ending
    - match: (?i)^\s*(%)(pragma){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.macro.nasm keyword.control.preprocessor.assignment.nasm
      push: preprocessor-pragma
    - match: (?i)^\s*(%)(aliases){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.macro.nasm keyword.control.preprocessor.assignment.nasm
      push:
        - include: comments
        - include: whitespace
        - match: (?i){{stt_b}}(?:on|true|yes){{end_b}}
          scope: entity.name.tag.preprocessor-aliases.true.nasm
        - match: (?i){{stt_b}}(?:off|false|no){{end_b}}
          scope: entity.name.tag.preprocessor-aliases.true.nasm
        - match: '{{stt_b}}\d+{{end_b}}'
          scope: constant.numeric.value.nasm
        - match: '{{line_rem}}'
          scope: invalid.illegal.nasm
          pop: true
    - match: (?i)^\s*(%)(clear){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
      push:
        - meta_content_scope: meta.preprocessor.macro.nasm
        - include: whitespace
        - include: comments
        - match: (?i){{stt_b}}(?:all|(?:all)?def(?:ine)?|smacro|defalias|s?alias|m?macro|context|ctx|global|nothing|none|ignore){{end_b}}
          scope: support.constant.macro.nasm
        - match: \-\-?(?=\s|$)
          scope: support.constant.macro.nasm
        - match: \S+
          scope: invalid.illegal.nasm
    - match: (?i)^\s*(%)(arg|local){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
      push:
        - meta_content_scope: meta.preprocessor.macro.nasm
        - match: ({{valid_identifier}})(:)(?=\w+)
          captures:
            1: meta.preprocessor.nasm variable.parameter.macro.nasm
            2: punctuation.separator.nasm
        - match: \,
          scope: punctuation.separator.nasm
        - include: data-types
        - match: \w+{{end_b}}
          scope: invalid.illegal.storage.type.nasm
        - include: whitespace
    - match: (?i)^\s*(%)(stacksize){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
      push:
        - meta_content_scope: meta.preprocessor.macro.nasm
        - match: (?i){{stt_b}}(?:flat(?:64)?|large|small){{end_b}}
          scope: support.constant.macro.nasm
        - match: \w+{{end_b}}
          scope: invalid.illegal.storage.type.nasm
        - include: whitespace
    - match: (?i)^\s*(%)(null|note){{end_b}}
      # TODO: `%note` isn't actually in the language full release yet as of 1/19/25,
      # so I don't actually know what the syntax is. The commit that added it says
      # adds a note in the list file. It doesn't give an example so idk.
      #     8d62e99e140f20dcab6d1568fe9b3734b5f3b61d
      #     (https://github.com/netwide-assembler/nasm/commit/<commit>)
      #
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
      push:
        - meta_content_scope: comment.line.nasm
        - include: whitespace
  preprocessor-single-line-macro-params-invalid:
    - meta_scope: invalid.illegal.nasm
    - include: preprocessor-single-line-macro-params
  preprocessor-single-line-macro-params:
    - meta_scope: meta.preprocessor.macro.parameters.nasm meta.group.nasm
    # TODO: make !=, //, / without prior =, etc. show as invalid
    # NOTE: as of 2.15, unused parameters don't need identifiers.
    # the operator things work on both sides, and can be repeated for some reason.
    - match: ([+=!& ]*)({{valid_identifier}})?([+=!& ]*(?i:/[bdhoqstuxy+=!&/ ]+)?)
      captures:
        1: keyword.declaration.nasm
        2: variable.parameter.nasm
        3: keyword.declaration.nasm
    - match: \)
      scope: punctuation.section.group.end.nasm
      set: preprocessor-single-line-macro-definition
    - match: \,
      scope: punctuation.separator.nasm
    - include: line-continuation
    - match: \.{3}
      scope: keyword.operator.variadic.nasm
    - match: '[+=!&/\w]'
      scope: keyword.operator.nasm
    - match: $\n
      scope: invalid.illegal.unexpected-end-of-line.nasm
  preprocessor-single-line-macro-definition:
    # basically, this context gets pushed after `%define x()` or `%include`, etc.
    # It is super short, and is only ever used 3 times,
    # so it should probably just be made inline.
    - meta_content_scope: meta.preprocessor.macro.nasm
    - include: preprocessor-conditions-constant
    - include: whitespace
    - include: main
  preprocessor-conditions:
    # also see preprocessor-macro-conditions
    - match: (?i)^\s*(%)(ifn?(?:idni?|id|num|str|token|empty|env|usable|using|difi)?){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
      push: preprocessor-conditions-content-block
    - match: (?i)^\s*(%)(ifn?(?:def(?:alias)?|ctx)){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
      push: [preprocessor-conditions-content-block, preprocessor-conditions-constant]
    - match: (?i)^\s*(%)(rep){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
      push: preprocessor-conditions-content-block
    - match: (?i)^\s*(%)(ifn?macro){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
      push: [preprocessor-conditions-content-block, preprocessor-macro-param-signature]
    - include: preprocessor-conditions-else-end-invalid
  preprocessor-conditions-constant:
    # TODO: figure out what this context does, or if it is even required
    - meta_content_scope: meta.preprocessor.nasm
    - match: (?:{{valid_identifier}})(?=\()
      scope: entity.name.constant.preprocessor.nasm
      set:
        - match: \(
          scope: punctuation.section.group.begin.nasm
          set: preprocessor-single-line-macro-params-invalid
    - match: '{{valid_identifier}}{{end_b}}'
      scope: meta.preprocessor.nasm entity.name.constant.preprocessor.nasm
      pop: true
    - include: whitespace
    - include: pop-if-not-whitespace
    - include: main
  preprocessor-conditions-content-block:
    - meta_content_scope: meta.block.preprocessor.nasm
    - include: preprocessor-conditions-else-end
    - include: main
  preprocessor-conditions-else-end:
    - match: (?i)^\s*(%)(elifn?(?:idni?|id|num|str|token|empty|env|usable|using|difi)?|else|exitrep){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
    - match: (?i)^\s*(%)(elifn?(?:def(?:alias)?|ctx)){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
      push: preprocessor-conditions-constant
    - match: (?i)^\s*(%)(elifn?macro){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
      push: preprocessor-macro-param-signature
      # TODO: separate `if` and `rep` so `%if ... %endrep` isn't considered valid.
    - match: (?i)^\s*(%)(end(?:if|rep)){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
      pop: true
  preprocessor-conditions-else-end-invalid:
    # basically stuff like `%endif` without `%if`.
    - match: (?i)^\s*(%)(el{{if_directive}}|else|endif|(?:end|exit)rep){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: invalid.illegal.meta.preprocessor.nasm keyword.control.preprocessor.nasm
  preprocessor-macro:
    - match: (?i)^\s*(%)(i?r?macro){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.macro.nasm keyword.control.import.define.nasm
      push:
        - meta_content_scope: meta.preprocessor.macro.nasm
        - match: (?:{{valid_identifier}})(?=\()
          scope: entity.name.constant.preprocessor.nasm
          set:
            - meta_content_scope: invalid.illegal.nasm
            - match: \(
              scope: punctuation.section.group.begin.nasm
              set: preprocessor-single-line-macro-params-invalid
        - match: ({{valid_identifier}})\s+(\d+(?:(-)(?:\*|\d+))?)(\+)?(\.(?i:nolist){{end_b}})?
          captures:
            1: entity.name.function.preprocessor.nasm
            2: variable.parameter.preprocessor.nasm
            3: keyword.operator.preprocessor.range.nasm
            4: storage.modifier.preprocessor.greedy.nasm
            5: storage.modifier.preprocessor.listing.nasm
          set: preprocessor-macro-main
    - match: (?i)^\s*(%)(endm(?:acro)?|exitmacro|rotate){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: invalid.illegal.meta.preprocessor.nasm keyword.control.import.nasm
  preprocessor-macro-param-signature:
    - meta_scope: meta.preprocessor.nasm
    - match: ({{valid_identifier}})\s+(\d+(?:(-)(?:\*|\d+))?)(\+)?(\.(?i:nolist){{end_b}})?
      captures:
        1: entity.name.function.preprocessor.nasm
        2: variable.parameter.preprocessor.nasm
        3: keyword.operator.preprocessor.range.nasm
        4: storage.modifier.preprocessor.greedy.nasm
        5: storage.modifier.preprocessor.listing.nasm
      pop: true
    - include: whitespace
    - include: pop-if-not-whitespace
  preprocessor-macro-parameter:
    - match: (%)(\-?\d+)
      scope: meta.preprocessor.nasm
      captures:
        1: punctuation.definition.variable.preprocessor.nasm keyword.control.preprocessor.nasm
        2: variable.other.preprocessor.nasm
  preprocessor-macro-main:
    - meta_content_scope: meta.preprocessor.macro.nasm
    - include: macro-comments
    - include: preprocessor-special-tokens
    - include: preprocessor-macro-conditions
    - include: preprocessor-macro-content-block
    # - include: main # already included from `preprocessor-macro-content-block`
  preprocessor-macro-content-block:
    # macro-only things.
    - meta_content_scope: meta.preprocessor.macro.nasm
    - match: (?i)^\s*(%)(endm(?:acro)?){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.import.nasm
      pop: true
    - match: (?i)^\s*(%)(exitmacro){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.import.nasm
    - match: (?i)^\s*(%)(rotate){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.operator.word.nasm
    - match: (%%)({{valid_identifier}}){{end_b}}\s*(:?)
      scope: meta.preprocessor.nasm
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm keyword.control.preprocessor.nasm
        2: entity.name.constant.special.nasm
        3: punctuation.separator.nasm
    - match: (%)({)
      scope: meta.preprocessor.macro.nasm keyword.control.preprocessor.nasm
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.braces.nasm punctuation.section.braces.begin.nasm
      push:
        - meta_scope: meta.braces.nasm meta.preprocessor.macro.nasm
        - include: preprocessor-special-tokens
        - match: ':'
          scope: punctuation.separator.nasm
        - match: \}
          scope: punctuation.section.braces.end.nasm
          pop: true

    - include: preprocessor-macro-parameter
    - include: preprocessor-special-tokens
    - include: preprocessor-conditions
    - include: main
  preprocessor-macro-conditions:
    # also see preprocessor-conditions
    - match: (?i)^\s*(%)(ifn?(?:idni?|id|num|str|token|empty|env|usable|using|difi)?){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
      push: preprocessor-macro-conditions-content-block
    - match: (?i)^\s*(%)(ifn?(?:def(?:alias)?|ctx)){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
      push: [preprocessor-macro-conditions-content-block, preprocessor-conditions-constant]
    - match: (?i)^\s*(%)(rep){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
      push: preprocessor-macro-conditions-content-block
    - match: (?i)^\s*(%)(ifn?macro){{end_b}}
      captures:
        1: punctuation.definition.keyword.preprocessor.nasm
        2: meta.preprocessor.nasm keyword.control.preprocessor.nasm
      push: [preprocessor-macro-param-signature, preprocessor-macro-conditions-content-block]

    - include: preprocessor-conditions-else-end-invalid
  preprocessor-macro-conditions-content-block:
    - meta_content_scope: meta.block.preprocessor.nasm
    - include: preprocessor-conditions-else-end
    - include: preprocessor-macro-main

  strings:
    # Character strings: https://www.nasm.us/doc/nasmdoc3.html#section-3.4.2
    - match: \`
      scope: punctuation.definition.string.begin.nasm
      push: string-backquote
    - match: \'
      scope: punctuation.definition.string.begin.nasm
      push: string-single
    - match: \"
      scope: punctuation.definition.string.begin.nasm
      push: string-double
  string-end:
    - include: line-continuation
    - match: \n
      # strings have to end on the same line
      scope: invalid.illegal.string.end.nasm
      pop: true
  string-content:
    - match: \\U[\da-fA-F]{8}
      scope: constant.character.escape.nasm
    - match: (?i)\\u[\da-f]{4}
      scope: constant.character.escape.nasm
    - match: (?i)\\x[\da-f]{1,2}
      scope: constant.character.escape.nasm
    - match: \\[0-7]{1,3}
      scope: constant.character.escape.nasm
    - match: \\['"`\\?abtnvfre]
      scope: constant.character.escape.nasm
    - match: \\.
      scope: invalid.illegal.constant.character.escape.nasm
    - include: string-end
  string-backquote:
    - meta_scope: string.quoted.other.nasm
    - meta_include_prototype: false
    - include: string-content
    - match: \`
      scope: punctuation.definition.string.end.nasm
      pop: true
  string-single:
    - meta_scope: string.quoted.single.nasm
    - meta_include_prototype: false
    - include: string-end
    - match: \'
      scope: punctuation.definition.string.end.nasm
      pop: true
  string-double:
    - meta_scope: string.quoted.double.nasm
    - meta_include_prototype: false
    - include: string-end
    - match: \"
      scope: punctuation.definition.string.end.nasm
      pop: true

  # table of allowed syntax for general-purpose registers.
  # 8[hl] : higher/lower 8 bit
  # 
  #              Classic    Pointer Index             Numbered-only            
  #           A   C   D   B  S   B  S   D  8   9   10   11   12   13   14   15 
  # 
  #  8h       ah ch dh bh                                                   
  #  8h alt  r0hr1hr2hr3h                                     
  #  8l alt br0br1br2br3br4br5br6br7b
  #  8l alt lr0lr2lr3lr1lr4lr5lr6lr7lr8lr9lr10lr11lr12lr13lr14lr15l
  #  8l       al cl dl blsplbplsildilr8br9br10br11br12br13br14br15b
  #  16       ax cx dx bx spbp si di r8wr9wr10wr11wr12wr13wr14wr15w
  #  16 alt  r0wr1wr2wr3wr4wr5wr6wr7w
  #  32      eaxecxedxebxespebpesiedir8dr9dr10dr11dr12dr13dr14dr15d
  #  32 alt  r0dr1dr2dr3dr4dr5dr6dr7d
  #  64      raxrcxrdxrbxrsprbprsirdir8 r9 r10 r11 r12 r13 r14 r15 
  #  64 alt  r0 r1 r2 r3 r4 r5 r6 r7 
  # 
  # registers are only pulled out into their own context if they are used as an argument to at least one instruction.

  # all the registers defined in these two locations:
    # https://github.com/netwide-assembler/nasm/blob/nasm-2.16.xx/x86/regs.dat
    # https://github.com/netwide-assembler/nasm/blob/nasm-2.16.xx/macros/altreg.mac
  # these types are all using the same type names as used here (2nd column):
    # https://github.com/netwide-assembler/nasm/blob/nasm-2.16.xx/x86/insns.dat

  reg_al:
    - match: (?i){{stt_b}}al{{end_b}}
      scope: constant.language.reg_al.nasm constant.language.reg8.classic.nasm
    - match: (?i){{stt_b}}r0[bl]{{end_b}}
      scope: constant.language.reg_al.nasm constant.language.reg8.classic.altreg.nasm
  reg_cl:
    - match: (?i){{stt_b}}cl{{end_b}}
      scope: constant.language.reg_cl.nasm constant.language.reg8.classic.nasm
    - match: (?i){{stt_b}}r1[bl]{{end_b}}
      scope: constant.language.reg_cl.nasm constant.language.reg8.classic.altreg.nasm
  reg8:
    - include: reg_al
    - include: reg_cl
    - match: (?i){{stt_b}}(?:[bd]l|[a-d]h){{end_b}}
      scope: constant.language.reg8.classic.nasm
    - match: (?i){{stt_b}}[bs]pl{{end_b}}
      scope: constant.language.reg8.pointer.nasm
    - match: (?i){{stt_b}}[ds]il{{end_b}}
      scope: constant.language.reg8.index.nasm
    - match: (?i){{stt_b}}r(?:8|9|1[0-5])b{{end_b}}
      scope: constant.language.reg8.numbered.nasm
    # altreg
    - match: (?i){{stt_b}}r(?:8|9|1[0-5])l{{end_b}}
      scope: constant.language.reg8.numbered.altreg.nasm
    - match: (?i){{stt_b}}r[23][bl]{{end_b}}
      scope: constant.language.reg8.classic.altreg.nasm
    - match: (?i){{stt_b}}r[45][bl]{{end_b}}
      scope: constant.language.reg8.pointer.altreg.nasm
    - match: (?i){{stt_b}}r[67][bl]{{end_b}}
      scope: constant.language.reg8.index.altreg.nasm

  reg_ax:
    - match: (?i){{stt_b}}ax{{end_b}}
      scope: constant.language.reg_ax.nasm constant.language.reg16.classic.nasm
    - match: (?i){{stt_b}}r0w{{end_b}}
      scope: constant.language.reg_ax.nasm constant.language.reg16.classic.altreg.nasm
  reg_cx:
    - match: (?i){{stt_b}}cx{{end_b}}
      scope: constant.language.reg_cx.nasm constant.language.reg16.classic.nasm
    - match: (?i){{stt_b}}r1w{{end_b}}
      scope: constant.language.reg_cx.nasm constant.language.reg16.classic.altreg.nasm
  reg_dx:
    - match: (?i){{stt_b}}dx{{end_b}}
      scope: constant.language.reg_dx.nasm constant.language.reg16.classic.nasm
    - match: (?i){{stt_b}}r2w{{end_b}}
      scope: constant.language.reg_dx.nasm constant.language.reg16.classic.altreg.nasm
  reg16:
    - include: reg_ax
    - include: reg_cx
    - include: reg_dx
    - match: (?i){{stt_b}}bx{{end_b}}
      scope: constant.language.reg16.classic.nasm
    - match: (?i){{stt_b}}[bs]p{{end_b}}
      scope: constant.language.reg16.pointer.nasm
    - match: (?i){{stt_b}}[ds]i{{end_b}}
      scope: constant.language.reg16.index.nasm
    - match: (?i){{stt_b}}r(?:8|9|1[0-5])w{{end_b}}
      scope: constant.language.reg16.numbered.nasm
    # altreg
    - match: (?i){{stt_b}}r3w{{end_b}}
      scope: constant.language.reg16.classic.altreg.nasm
    - match: (?i){{stt_b}}r[45]w{{end_b}}
      scope: constant.language.reg16.pointer.altreg.nasm
    - match: (?i){{stt_b}}r[67]w{{end_b}}
      scope: constant.language.reg16.index.altreg.nasm

  reg_eax:
    - match: (?i){{stt_b}}eax{{end_b}}
      scope: constant.language.reg_eax.nasm constant.language.reg32.classic.nasm
    - match: (?i){{stt_b}}r0d{{end_b}}
      scope: constant.language.reg_eax.nasm constant.language.reg32.classic.altreg.nasm
  reg_ecx:
    - match: (?i){{stt_b}}ecx{{end_b}}
      scope: constant.language.reg_ecx.nasm constant.language.reg32.classic.nasm
    - match: (?i){{stt_b}}r1d{{end_b}}
      scope: constant.language.reg_ecx.nasm constant.language.reg32.classic.altreg.nasm
  reg_edx:
    - match: (?i){{stt_b}}edx{{end_b}}
      scope: constant.language.reg_edx.nasm constant.language.reg32.classic.nasm
    - match: (?i){{stt_b}}r2d{{end_b}}
      scope: constant.language.reg_edx.nasm constant.language.reg32.classic.altreg.nasm
  reg32na:
    - match: (?i){{stt_b}}ebx{{end_b}}
      scope: constant.language.reg32na.nasm constant.language.reg32.classic.nasm
    - match: (?i){{stt_b}}e[bs]p{{end_b}}
      scope: constant.language.reg32na.nasm constant.language.reg32.pointer.nasm
    - match: (?i){{stt_b}}e[ds]i{{end_b}}
      scope: constant.language.reg32na.nasm constant.language.reg32.index.nasm
    - match: (?i){{stt_b}}r(?:8|9|1[0-5])d{{end_b}}
      scope: constant.language.reg32na.nasm constant.language.reg32.numbered.nasm
    # altreg
    - match: (?i){{stt_b}}r3d{{end_b}}
      scope: constant.language.reg32na.altreg.nasm constant.language.reg32.classic.altreg.nasm
    - match: (?i){{stt_b}}r[45]d{{end_b}}
      scope: constant.language.reg32na.altreg.nasm constant.language.reg32.pointer.altreg.nasm
    - match: (?i){{stt_b}}r[67]d{{end_b}}
      scope: constant.language.reg32na.altreg.nasm constant.language.reg32.index.altreg.nasm
  reg32:
    - include: reg_eax
    - include: reg_ecx
    - include: reg_edx
    - include: reg32na

  reg_rax:
    - match: (?i){{stt_b}}rax{{end_b}}
      scope: constant.language.reg_rax.nasm constant.language.reg64.classic.nasm
    - match: (?i){{stt_b}}r0{{end_b}}
      scope: constant.language.reg_rax.nasm constant.language.reg64.classic.altreg.nasm
  reg_rcx:
    - match: (?i){{stt_b}}rcx{{end_b}}
      scope: constant.language.reg_rcx.nasm constant.language.reg64.classic.nasm
    - match: (?i){{stt_b}}r1{{end_b}}
      scope: constant.language.reg_rcx.nasm constant.language.reg64.classic.altreg.nasm
  reg64:
    - include: reg_rax
    - include: reg_rcx
    - match: (?i){{stt_b}}r[bd]x{{end_b}}
      scope: constant.language.reg64.classic.nasm
    - match: (?i){{stt_b}}r[bs]p{{end_b}}
      scope: constant.language.reg64.pointer.nasm
    - match: (?i){{stt_b}}r[ds]i{{end_b}}
      scope: constant.language.reg64.index.nasm
    - match: (?i){{stt_b}}r(?:8|9|1[0-5]){{end_b}}
      scope: constant.language.reg64.numbered.nasm
    # altreg
    - match: (?i){{stt_b}}r[23]{{end_b}}
      scope: constant.language.reg64.classic.altreg.nasm
    - match: (?i){{stt_b}}r[45]{{end_b}}
      scope: constant.language.reg64.pointer.altreg.nasm
    - match: (?i){{stt_b}}r[67]{{end_b}}
      scope: constant.language.reg64.index.altreg.nasm

  reg_cs:
    - match: (?i){{stt_b}}cs{{end_b}}
      scope: constant.language.reg_cs.nasm constant.language.reg_sreg.nasm
  reg_ds:
    - match: (?i){{stt_b}}ds{{end_b}}
      scope: constant.language.reg_ds.nasm constant.language.reg_sreg.nasm
  reg_es:
    - match: (?i){{stt_b}}es{{end_b}}
      scope: constant.language.reg_es.nasm constant.language.reg_sreg.nasm
  reg_fs:
    - match: (?i){{stt_b}}fs{{end_b}}
      scope: constant.language.reg_fs.nasm constant.language.reg_sreg.nasm
  reg_gs:
    - match: (?i){{stt_b}}gs{{end_b}}
      scope: constant.language.reg_gs.nasm constant.language.reg_sreg.nasm
  reg_ss:
    - match: (?i){{stt_b}}ss{{end_b}}
      scope: constant.language.reg_ss.nasm constant.language.reg_sreg.nasm
  reg_sreg:
    - include: reg_cs
    - include: reg_ds
    - include: reg_es
    - include: reg_fs
    - include: reg_gs
    - include: reg_ss
    - match: (?i){{stt_b}}segr[67]{{end_b}}
      scope: constant.language.reg_sreg.nasm

  reg_creg:
    - match: (?i){{stt_b}}cr(?:\d|1[0-5]){{end_b}}
      scope: constant.language.reg.creg.nasm

  reg_dreg:
    - match: (?i){{stt_b}}dr(?:\d|1[0-5]){{end_b}}
      scope: constant.language.reg.dreg.nasm

  reg_treg:
    - match: (?i){{stt_b}}tr[0-7]{{end_b}}
      scope: constant.language.reg.treg.nasm

  fpu0:
    - match: (?i){{stt_b}}st0{{end_b}}
      scope: constant.language.fpu0.nasm constant.language.fpureg.nasm
  fpureg:
    - include: fpu0
    - match: (?i){{stt_b}}st[1-7]{{end_b}}
      scope: constant.language.fpureg.nasm

  mmxreg:
    - match: (?i){{stt_b}}mm[0-7]{{end_b}}
      scope: constant.language.mmxreg.nasm

  xmm0:
    - match: (?i){{stt_b}}xmm0{{end_b}}
      scope: constant.language.xmm0.nasm constant.language.xmmreg.nasm
  xmmreg:
    # SSE registers
    - include: xmm0
    - match: (?i){{stt_b}}xmm(?:[1-9]|[12]\d|3[01]){{end_b}}
      scope: constant.language.xmmreg.nasm

  ymmreg:
    - match: (?i){{stt_b}}ymm(?:[12]?\d|3[01]){{end_b}}
      scope: constant.language.ymmreg.nasm

  zmmreg:
    - match: (?i){{stt_b}}zmm(?:[12]?\d|3[01]){{end_b}}
      scope: constant.language.zmmreg.nasm

  tmmreg:
    - match: (?i){{stt_b}}tmm[0-7]{{end_b}}
      scope: constant.language.tmmreg.nasm

  kreg:
    # TODO: figure out what kreg(?:8|16|32|64) are.
    - match: (?i){{stt_b}}k[0-7]{{end_b}}
      scope: constant.language.kreg.nasm

  bndreg:
    - match: (?i){{stt_b}}bnd[0-3]{{end_b}}
      scope: constant.language.bndreg.nasm

  registers:
    - include: reg8
    - include: reg16
    - include: reg32
    - include: reg64
    - include: reg_sreg
    - include: reg_creg
    - include: reg_dreg
    - include: reg_treg
    - include: fpureg
    - include: mmxreg
    - include: xmmreg
    - include: ymmreg
    - include: zmmreg
    - include: tmmreg
    - include: kreg
    - include: bndreg

  # TODO: Intel MPX instructions are removed.
    # section F.1.39 Intel Memory Protection Extensions (MPX)

  # TODO: update the instructions. It is missing 606 of them.
  # TODO: also make the highlighting stricter.
    # so if instruction `ASDF` only ever accepts one argument of `reg64`, only allow that, etc.
  mnemonics:
    - include: mnemonics-general-purpose
    - include: mnemonics-fpu
    - include: mnemonics-mmx
    - include: mnemonics-sse
    - include: mnemonics-sse2
    - include: mnemonics-sse3
    - include: mnemonics-sse4
    - include: mnemonics-aesni
    - include: mnemonics-avx
    - include: mnemonics-avx2
    - include: mnemonics-tsx
    - include: mnemonics-system
    - include: mnemonics-64bit
    - include: mnemonics-vmx
    - include: mnemonics-smx
    - include: mnemonics-intel-isa-sgx
    - include: mnemonics-intel-isa-mpx
    - include: mnemonics-intel-isa-sha
    - include: mnemonics-supplemental-amd
    - include: mnemonics-supplemental-cyrix
    - include: mnemonics-supplemental-via
    - include: mnemonics-undocumented
    - include: mnemonics-future-intel
    - include: mnemonics-pseudo-ops
    # - include: mnemonics-invalid
  mnemonics-general-purpose:
    - match: (?i){{stt_b}}(?:mov(?:[sz]x)?|cmov(?:n?[abceglopsz]|n?[abgl]e|p[eo])){{end_b}}
      scope: keyword.operator.word.mnemonic.general-purpose.data-transfer.mov
    - match: (?i){{stt_b}}(xchg|bswap|xadd|cmpxchg(8b)?){{end_b}}
      scope: keyword.operator.word.mnemonic.general-purpose.data-transfer.xchg
    - match: (?i){{stt_b}}((push|pop)(ad?)?|cwde?|cdq|cbw){{end_b}}
      scope: keyword.operator.word.mnemonic.general-purpose.data-transfer.other
    - match: (?i){{stt_b}}(adcx?|adox|add|sub|sbb|i?mul|i?div|inc|dec|neg|cmp){{end_b}}
      scope: keyword.operator.word.mnemonic.general-purpose.binary-arithmetic
    - match: (?i){{stt_b}}(daa|das|aaa|aas|aam|aad){{end_b}}
      scope: keyword.operator.word.mnemonic.general-purpose.decimal-arithmetic
    - match: (?i){{stt_b}}(and|x?or|not){{end_b}}
      scope: keyword.operator.word.mnemonic.general-purpose.logical
    - match: (?i){{stt_b}}(s[ah][rl]|sh[rl]d|r[co][rl]){{end_b}}
      scope: keyword.operator.word.mnemonic.general-purpose.rotate
    - match: (?i){{stt_b}}(set(n?[abceglopsz]|n?[abgl]e|p[eo])){{end_b}}
      scope: keyword.operator.word.mnemonic.general-purpose.bit-and-byte.set
    - match: (?i){{stt_b}}(bt[crs]?|bs[fr]|test|crc32|popcnt){{end_b}}
      scope: keyword.operator.word.mnemonic.general-purpose.bit-and-byte.other
    - match: (?i){{stt_b}}(jmp|jn?[abceglopsz]|jn?[abgl]e|jp[eo]|j[er]?cxz){{end_b}}
      scope: keyword.operator.word.mnemonic.general-purpose.control-transfer.jmp
    - match: (?i){{stt_b}}(loop(n?[ez])?|call|ret|iret[dq]?|into?|bound|enter|leave){{end_b}}
      scope: keyword.operator.word.mnemonic.general-purpose.control-transfer.other
    - match: (?i){{stt_b}}((mov|cmp|sca|lod|sto)(s[bdw]?)|rep(n?[ez])?){{end_b}}
      scope: keyword.operator.word.mnemonic.general-purpose.strings
    - match: (?i){{stt_b}}((in|out)(s[bdw]?)?){{end_b}}
      scope: keyword.operator.word.mnemonic.general-purpose.io
    - match: (?i){{stt_b}}((st|cl)[cdi]|cmc|[ls]ahf|(push|pop)f[dq]?){{end_b}}
      scope: keyword.operator.word.mnemonic.general-purpose.flag-control
    - match: (?i){{stt_b}}(l[defgs]s){{end_b}}
      scope: keyword.operator.word.mnemonic.general-purpose.segment-registers
    - match: (?i){{stt_b}}(lea|nop|ud2|xlatb?|cpuid|movbe){{end_b}}
      scope: keyword.operator.word.mnemonic.general-purpose.misc
    - match: (?i){{stt_b}}(rdrand|rdseed){{end_b}}
      scope: keyword.operator.word.mnemonic.general-purpose.rng
    - match: (?i){{stt_b}}(andn|bextr|bls(i|r|msk)|bzhi|pdep|pext|[lt]zcnt|(mul|ror|sar|shl|shr)x){{end_b}}
      scope: keyword.operator.word.mnemonic.general-purpose.bmi
  mnemonics-fpu:
    - match: (?i){{stt_b}}(fcmov(n?([beu]|be))){{end_b}}
      scope: keyword.operator.word.mnemonic.fpu.data-transfer.mov
    - match: (?i){{stt_b}}(f(i?(ld|stp?)|b(ld|stp)|xch)){{end_b}}
      scope: keyword.operator.word.mnemonic.fpu.data-transfer.other
    - match: (?i){{stt_b}}(f((add|div|mul|sub)p?|i(add|div|mul|sub)|(div|sub)rp?|i(div|sub)r)){{end_b}}
      scope: keyword.operator.word.mnemonic.fpu.basic-arithmetic.basic
    - match: (?i){{stt_b}}(f(prem1?|abs|chs|rndint|scale|sqrt|xtract)){{end_b}}
      scope: keyword.operator.word.mnemonic.fpu.basic-arithmetic.other
    - match: (?i){{stt_b}}(f(u?com[ip]?p?|icomp?|tst|xam)){{end_b}}
      scope: keyword.operator.word.mnemonic.fpu.comparison
    - match: (?i){{stt_b}}(f(sin|cos|sincos|pa?tan|2xm1|yl2x(p1)?)){{end_b}}
      scope: keyword.operator.word.mnemonic.fpu.transcendental
    - match: (?i){{stt_b}}(fld(1|z|pi|l2[et]|l[ng]2)){{end_b}}
      scope: keyword.operator.word.mnemonic.fpu.load-constants
    - match: (?i){{stt_b}}(f((inc|dec)stp|free|n?(init|clex|st[cs]w|stenv|save)|ld(cw|env)|rstor|nop)|f?wait){{end_b}}
      scope: keyword.operator.word.mnemonic.fpu.control-management
    - match: (?i){{stt_b}}(fx(save|rstor)(64)?){{end_b}}
      scope: keyword.operator.word.mnemonic.fpu.state-management
  mnemonics-mmx:
    - match: (?i){{stt_b}}(mov[dq]){{end_b}}
      scope: keyword.operator.word.mnemonic.mmx.data-transfer
    - match: (?i){{stt_b}}(pack(ssdw|[su]swb)|punpck[hl](bw|dq|wd)){{end_b}}
      scope: keyword.operator.word.mnemonic.mmx.conversion
    - match: (?i){{stt_b}}(p(((add|sub)(d|(u?s)?[bw]))|maddwd|mul[lh]w)){{end_b}}
      scope: keyword.operator.word.mnemonic.mmx.packed-arithmetic
    - match: (?i){{stt_b}}(pcmp((eq|gt)[bdw])){{end_b}}
      scope: keyword.operator.word.mnemonic.mmx.comparison
    - match: (?i){{stt_b}}(pandn?|px?or){{end_b}}
      scope: keyword.operator.word.mnemonic.mmx.logical
    - match: (?i){{stt_b}}(ps([rl]l[dwq]|raw|rad)){{end_b}}
      scope: keyword.operator.word.mnemonic.mmx.shift-and-rotate
    - match: (?i){{stt_b}}(emms){{end_b}}
      scope: keyword.operator.word.mnemonic.mmx.state-management
  mnemonics-sse:
    - match: (?i){{stt_b}}(mov(([ahlu]|hl|lh|msk)ps|ss)){{end_b}}
      scope: keyword.operator.word.mnemonic.sse.data-transfer
    - match: (?i){{stt_b}}((add|div|max|min|mul|rcp|r?sqrt|sub)[ps]s){{end_b}}
      scope: keyword.operator.word.mnemonic.sse.packed-arithmetic
    - match: (?i){{stt_b}}(cmp[ps]s|u?comiss){{end_b}}
      scope: keyword.operator.word.mnemonic.sse.comparison
    - match: (?i){{stt_b}}((andn?|x?or)ps){{end_b}}
      scope: keyword.operator.word.mnemonic.sse.logical
    - match: (?i){{stt_b}}((shuf|unpck[hl])ps){{end_b}}
      scope: keyword.operator.word.mnemonic.sse.shuffle-and-unpack
    - match: (?i){{stt_b}}(cvt(pi2ps|si2ss|ps2pi|tps2pi|ss2si|tss2si)){{end_b}}
      scope: keyword.operator.word.mnemonic.sse.conversion
    - match: (?i){{stt_b}}((ld|st)mxcsr){{end_b}}
      scope: keyword.operator.word.mnemonic.sse.state-management
    - match: (?i){{stt_b}}(p(avg[bw]|extrw|insrw|(max|min)(sw|ub)|sadbw|shufw|mulhuw|movmskb)){{end_b}}
      scope: keyword.operator.word.mnemonic.sse.simd-integer
    - match: (?i){{stt_b}}(maskmovq|movntps|sfence){{end_b}}
      scope: keyword.operator.word.mnemonic.sse.cacheability-control
    - match: (?i){{stt_b}}(prefetch(nta|t[0-2]|w(t1)?)){{end_b}}
      scope: keyword.operator.word.mnemonic.sse.prefetch
  mnemonics-sse2:
    - match: (?i){{stt_b}}(mov([auhl]|msk)pd){{end_b}}
      scope: keyword.operator.word.mnemonic.sse2.data-transfer
    - match: (?i){{stt_b}}((add|div|max|min|mul|sub|sqrt)[ps]d){{end_b}}
      scope: keyword.operator.word.mnemonic.sse2.packed-arithmetic
    - match: (?i){{stt_b}}((andn?|x?or)pd){{end_b}}
      scope: keyword.operator.word.mnemonic.sse2.logical
    - match: (?i){{stt_b}}((cmpp|u?comis)d){{end_b}}
      scope: keyword.operator.word.mnemonic.sse2.compare
    - match: (?i){{stt_b}}((shuf|unpck[hl])pd){{end_b}}
      scope: keyword.operator.word.mnemonic.sse2.shuffle-and-unpack
    - match: (?i){{stt_b}}(cvt(dq2pd|pi2pd|ps2pd|pd2ps|si2sd|sd2ss|ss2sd|t?(pd2dq|pd2pi|sd2si))){{end_b}}
      scope: keyword.operator.word.mnemonic.sse2.conversion
    - match: (?i){{stt_b}}(cvt(dq2ps|ps2dq|tps2dq)){{end_b}}
      scope: keyword.operator.word.mnemonic.sse2.packed-floating-point
    - match: (?i){{stt_b}}(mov(dq[au]|q2dq|dq2q)){{end_b}}
      scope: keyword.operator.word.mnemonic.sse2.simd-integer.mov
    - match: (?i){{stt_b}}(p((add|sub|(s[lr]l|mulu|unpck[hl]q)d)q|shuf(d|[hl]w))){{end_b}}
      scope: keyword.operator.word.mnemonic.sse2.simd-integer.other
    - match: (?i){{stt_b}}(clflush|[lm]fence|pause|maskmovdqu|movnt(dq|i|pd)){{end_b}}
      scope: keyword.operator.word.mnemonic.sse2.cacheability-control
  mnemonics-sse3:
    - match: (?i){{stt_b}}(fisttp|lddqu|(addsub|h(add|sub))p[sd]|mov(sh|sl|d)dup|monitor|mwait){{end_b}}
      scope: keyword.operator.word.mnemonic.sse3
    - match: (?i){{stt_b}}(ph(add|sub)(s?w|d)){{end_b}}
      scope: keyword.operator.word.mnemonic.sse3.supplimental.horizontal-packed-arithmetic
    - match: (?i){{stt_b}}(p((abs|sign)[bdw]|maddubsw|mulhrsw|shufb|alignr)){{end_b}}
      scope: keyword.operator.word.mnemonic.sse3.supplimental.other
  mnemonics-sse4:
    - match: (?i){{stt_b}}(pmul(ld|dq)|dpp[ds]){{end_b}}
      scope: keyword.operator.word.mnemonic.sse4.1.arithmetic
    - match: (?i){{stt_b}}(movntdqa){{end_b}}
      scope: keyword.operator.word.mnemonic.sse4.1.load-hint
    - match: (?i){{stt_b}}(blendv?p[ds]|pblend(vb|w)){{end_b}}
      scope: keyword.operator.word.mnemonic.sse4.1.packed-blending
    - match: (?i){{stt_b}}(p(min|max)(u[dw]|s[bd])){{end_b}}
      scope: keyword.operator.word.mnemonic.sse4.1.packed-integer
    - match: (?i){{stt_b}}(round[ps][sd]){{end_b}}
      scope: keyword.operator.word.mnemonic.sse4.1.packed-floating-point
    - match: (?i){{stt_b}}((extract|insert)ps|p((ins|ext)(r[bdq]))){{end_b}}
      scope: keyword.operator.word.mnemonic.sse4.1.insertion-and-extraction
    - match: (?i){{stt_b}}(pmov([sz]x(b[dqw]|dq|wd|wq))){{end_b}}
      scope: keyword.operator.word.mnemonic.sse4.1.conversion
    - match: (?i){{stt_b}}(mpsadbw|phminposuw|ptest|pcmpeqq|packusdw){{end_b}}
      scope: keyword.operator.word.mnemonic.sse4.1.other
    - match: (?i){{stt_b}}(pcmp([ei]str[im]|gtq)){{end_b}}
      scope: keyword.operator.word.mnemonic.sse4.2
  mnemonics-aesni:
    - match: (?i){{stt_b}}(aes((dec|enc)(last)?|imc|keygenassist)|pclmulqdq){{end_b}}
      scope: keyword.operator.word.mnemonic.aesni
  mnemonics-avx:
    - match: (?i){{stt_b}}(v((test|permil|maskmov)p[ds]|zero(all|upper)|(perm2|insert|extract|broadcast)f128|broadcasts[ds])){{end_b}}
      scope: keyword.operator.word.mnemonic.avx
    - match: (?i){{stt_b}}(vaes((dec|enc)(last)?|imc|keygenassist)|vpclmulqdq){{end_b}}
      scope: keyword.operator.word.mnemonic.avx.promoted.aes
    - match: (?i){{stt_b}}(v((cmp[ps]|u?comis)[ds]|pcmp([ei]str[im]|(eq|gt)[bdqw]))){{end_b}}
      scope: keyword.operator.word.mnemonic.avx.promoted.comparison
    - match: (?i){{stt_b}}(v(cvt(dq2pd|dq2ps|pd2ps|ps2pd|sd2ss|si2sd|si2ss|ss2sd|t?(pd2dq|ps2dq|sd2si|ss2si)))){{end_b}}
      scope: keyword.operator.word.mnemonic.avx.promoted.conversion
    - match: (?i){{stt_b}}(vh((add|sub)p[ds])|vph((add|sub)([dw]|sw)|minposuw)){{end_b}}
      scope: keyword.operator.word.mnemonic.avx.promoted.horizontal-packed-arithmetic
    - match: (?i){{stt_b}}(v((andn?|x?or)p[ds])){{end_b}}
      scope: keyword.operator.word.mnemonic.avx.promoted.logical
    - match: (?i){{stt_b}}(v(mov(([ahl]|msk|nt|u)p[ds]|(hl|lh)ps|s([ds]|[hl]dup)|q))){{end_b}}
      scope: keyword.operator.word.mnemonic.avx.promoted.mov
    - match: (?i){{stt_b}}(v((add|div|mul|sub|max|min|round|sqrt)[ps][ds]|(addsub|dp)p[ds]|(rcp|rsqrt)[ps]s)){{end_b}}
      scope: keyword.operator.word.mnemonic.avx.promoted.packed-arithmetic
    - match: (?i){{stt_b}}(v(pack[su]s(dw|wb)|punpck[hl](bw|dq|wd|qdq)|unpck[hl]p[ds])){{end_b}}
      scope: keyword.operator.word.mnemonic.avx.promoted.packed-conversion
    - match: (?i){{stt_b}}(vp(shuf([bd]|[hl]w))|vshufp[ds]){{end_b}}
      scope: keyword.operator.word.mnemonic.avx.promoted.packed-shuffle
    - match: (?i){{stt_b}}(vp((abs|sign|(max|min)[su])[bdw]|(add|sub)([bdqw]|u?s[bw])|avg[bw]|extr[bdqw]|madd(wd|ubsw)|mul(hu?w|hrsw|l[dw]|u?dq)|sadbw)){{end_b}}
      scope: keyword.operator.word.mnemonic.avx.promoted.supplemental.arithmetic
    - match: (?i){{stt_b}}(vp(andn?|x?or)){{end_b}}
      scope: keyword.operator.word.mnemonic.avx.promoted.supplemental.logical
    - match: (?i){{stt_b}}(vpblend(vb|w)){{end_b}}
      scope: keyword.operator.word.mnemonic.avx.promoted.supplemental.blending
    - match: (?i){{stt_b}}(vpmov(mskb|[sz]x(b[dqw]|w[dq]|dq))){{end_b}}
      scope: keyword.operator.word.mnemonic.avx.promoted.supplemental.mov
    - match: (?i){{stt_b}}(vp(insr[bdqw]|sll(dq|[dqw])|srl(dq))){{end_b}}
      scope: keyword.operator.word.mnemonic.avx.promoted.simd-integer
    - match: (?i){{stt_b}}(vp(sra[dwq]|srl[dqw])){{end_b}}
      scope: keyword.operator.word.mnemonic.avx.promoted.shift-and-rotate
    - match: (?i){{stt_b}}(vblendv?p[ds]){{end_b}}
      scope: keyword.operator.word.mnemonic.avx.promoted.packed-blending
    - match: (?i){{stt_b}}(vp(test|alignr)){{end_b}}
      scope: keyword.operator.word.mnemonic.avx.promoted.packed-other
    - match: (?i){{stt_b}}(vmov(d(dup|qa|qu)?)){{end_b}}
      scope: keyword.operator.word.mnemonic.avx.promoted.simd-integer.mov
    - match: (?i){{stt_b}}(v((extract|insert)ps|lddqu|(ld|st)mxcsr|mpsadbw)){{end_b}}
      scope: keyword.operator.word.mnemonic.avx.promoted.other
    - match: (?i){{stt_b}}(v(maskmovdqu|movntdqa?)){{end_b}}
      scope: keyword.operator.word.mnemonic.avx.promoted.cacheability-control
    - match: (?i){{stt_b}}(vcvt(ph2ps|ps2ph)){{end_b}}
      scope: keyword.operator.word.mnemonic.16-bit-floating-point-conversion
    - match: (?i){{stt_b}}(vfn?m((add|sub)(132|213|231)[ps][ds])|vfm((addsub|subadd)(132|213|231)p[ds])){{end_b}}
      scope: keyword.operator.word.mnemonic.fma
  mnemonics-avx2:
    - match: (?i){{stt_b}}(v((broadcast|extract|insert|perm2)i128|pmaskmov[dq]|perm([dsq]|p[sd]))){{end_b}}
      scope: keyword.operator.word.mnemonic.avx2.promoted.simd
    - match: (?i){{stt_b}}(vpbroadcast[bdqw]){{end_b}}
      scope: keyword.operator.word.mnemonic.avx2.promoted.packed
    - match: (?i){{stt_b}}(vp(blendd|s[lr]lv[dq]|sravd)){{end_b}}
      scope: keyword.operator.word.mnemonic.avx2.blend
    - match: (?i){{stt_b}}(vp?gather[dq][dq]|vgather([dq]|dq)p[ds]){{end_b}}
      scope: keyword.operator.word.mnemonic.avx2.gather
  mnemonics-tsx:
    - match: (?i){{stt_b}}(x(abort|acquire|release|begin|end|test)){{end_b}}
      scope: keyword.operator.word.mnemonic.tsx
  mnemonics-system:
    - match: (?i){{stt_b}}((cl|st)ac|[ls]([gli]dt|tr|msw)|clts|arpl|lar|lsl|ver[rw]|inv(d|lpg|pcid)|wbinvd){{end_b}}
      scope: keyword.operator.word.mnemonic.system
    - match: (?i){{stt_b}}(lock|hlt|rsm|(rd|wr)(msr|pkru|[fg]sbase)|rd(pmc|tscp?)|sys(enter|exit)){{end_b}}
      scope: keyword.operator.word.mnemonic.system
    - match: (?i){{stt_b}}(x((save(c|opt|s)?|rstors?)(64)?|[gs]etbv)){{end_b}}
      scope: keyword.operator.word.mnemonic.system
  mnemonics-64bit:
    - match: (?i){{stt_b}}(cdqe|cqo|(cmp|lod|mov|sto)sq|cmpxchg16b|mov(ntq|sxd)|scasq|swapgs|sys(call|ret)){{end_b}}
      scope: keyword.operator.word.mnemonic.64-bit-mode
  mnemonics-vmx:
    - match: (?i){{stt_b}}(vm(ptr(ld|st)|clear|read|write|launch|resume|xo(ff|n)|call|func)|inv(ept|vpid)){{end_b}}
      scope: keyword.operator.word.mnemonic.vmx
  mnemonics-smx:
    - match: (?i){{stt_b}}(getsec){{end_b}}
      scope: keyword.operator.word.mnemonic.smx.getsec
    - match: (?i){{stt_b}}(capabilities|enteraccs|exitac|senter|sexit|parameters|smctrl|wakeup){{end_b}}
      scope: support.constant
  mnemonics-intel-isa-sgx:
    - match: (?i){{stt_b}}e(add|block|create|dbg(rd|wr)|extend|init|ld[bu]|pa|remove|track|wb){{end_b}}
      scope: keyword.operator.word.mnemonic.sgx1.supervisor
    - match: (?i){{stt_b}}e(enter|exit|getkey|report|resume){{end_b}}
      scope: keyword.operator.word.mnemonic.sgx1.user
    - match: (?i){{stt_b}}e(aug|mod(pr|t)){{end_b}}
      scope: keyword.operator.word.mnemonic.sgx2.supervisor
    - match: (?i){{stt_b}}e(accept(copy)?|modpe){{end_b}}
      scope: keyword.operator.word.mnemonic.sgx2.user
  mnemonics-intel-isa-mpx:
    - match: (?i){{stt_b}}(bnd(mk|c[lnu]|mov|ldx|stx)){{end_b}}
      scope: keyword.operator.word.mnemonic.mpx
  mnemonics-intel-isa-sha:
    - match: (?i){{stt_b}}(sha(1rnds4|256rnds2|1nexte|(1|256)msg[12])){{end_b}}
      scope: keyword.operator.word.mnemonic.sha
  mnemonics-supplemental-amd:
    - match: (?i){{stt_b}}(bl([cs](fill|ic?|msk)|cs)|t1mskc|tzmsk){{end_b}}
      scope: keyword.operator.word.mnemonic.supplemental.amd.general-purpose
    - match: (?i){{stt_b}}(clgi|int3|invlpga|iretw|skinit|stgi|vm(load|mcall|run|save)|monitorx|mwaitx){{end_b}}
      scope: keyword.operator.word.mnemonic.supplemental.amd.system
    - match: (?i){{stt_b}}([ls]lwpcb|lwp(ins|val)){{end_b}}
      scope: keyword.operator.word.mnemonic.supplemental.amd.profiling
    - match: (?i){{stt_b}}(movnts[ds]){{end_b}}
      scope: keyword.operator.word.mnemonic.supplemental.amd.memory-management
    - match: (?i){{stt_b}}(prefetch|clzero){{end_b}}
      scope: keyword.operator.word.mnemonic.supplemental.amd.cache-management
    - match: (?i){{stt_b}}((extr|insert)q){{end_b}}
      scope: keyword.operator.word.mnemonic.supplemental.amd.sse4.a
    - match: (?i){{stt_b}}(vfn?m((add|sub)[ps][ds])|vfm((addsub|subadd)p[ds])){{end_b}}
      scope: keyword.operator.word.mnemonic.supplemental.amd.fma4
    - match: (?i){{stt_b}}(vp(cmov|(comu?|rot|sh[al])[bdqw]|mac(s?s(d(d|q[hl])|w[dw]))|madcss?wd|perm)){{end_b}}
      scope: keyword.operator.word.mnemonic.supplemental.amd.xop.simd
    - match: (?i){{stt_b}}(vph(addu?(b[dqw]|w[dq]|dq)|sub(bw|dq|wd))){{end_b}}
      scope: keyword.operator.word.mnemonic.supplemental.amd.xop.simd-horizontal
    - match: (?i){{stt_b}}(vfrcz[ps][ds]|vpermil2p[ds]){{end_b}}
      scope: keyword.operator.word.mnemonic.supplemental.amd.xop.other
    - match: (?i){{stt_b}}(femms){{end_b}}
      scope: keyword.operator.word.mnemonic.supplemental.amd.3dnow
    - match: (?i){{stt_b}}(p(avgusb|(f2i|i2f)[dw]|mulhrw|swapd)|pf((p?n)?acc|add|max|min|mul|rcp(it[12])?|rsqit1|rsqrt|subr?)){{end_b}}
      scope: keyword.operator.word.mnemonic.supplemental.amd.3dnow.simd
    - match: (?i){{stt_b}}(pfcmp(eq|ge|gt)){{end_b}}
      scope: keyword.operator.word.mnemonic.supplemental.amd.3dnow.comparison
  mnemonics-supplemental-cyrix:
    - match: (?i){{stt_b}}((sv|rs)dc|(wr|rd)shr|paddsiw){{end_b}}
      scope: keyword.operator.word.mnemonic.supplemental.cyrix
  mnemonics-supplemental-via:
    - match: (?i){{stt_b}}(montmul){{end_b}}
      scope: keyword.operator.word.mnemonic.supplemental.via
    - match: (?i){{stt_b}}(x(store(rng)?|crypt(ecb|cbc|ctr|cfb|ofb)|sha(1|256))){{end_b}}
      scope: keyword.operator.word.mnemonic.supplemental.via.padlock
  mnemonics-undocumented:
    - match: (?i){{stt_b}}(ret[nf]|icebp|int1|int03|smi|ud1){{end_b}}
      scope: keyword.operator.word.mnemonic.undocumented
  mnemonics-future-intel:
    - include: mnemonics-future-intel-avx512
    - include: mnemonics-future-intel-opmask
    - include: mnemonics-future-intel-cet
    - include: mnemonics-future-intel-other
  mnemonics-future-intel-avx512:
    - match: (?i){{stt_b}}(vblendm(pd|ps)|vpblendm[bdqw]){{end_b}}
      scope: keyword.operator.word.mnemonic.avx512.blend
    - match: (?i){{stt_b}}(vbroadcast[fi](32x[248]|64x[24])|v(extract|insert)[fi](32x[48]|64x[24])|vshuf[fi](32x4|64x2)|vpbroadcastm(b2q|w2d)){{end_b}}
      scope: keyword.operator.word.mnemonic.avx512.bits-mov
    - match: (?i){{stt_b}}(v(compress|expand)p[ds]|vp(compress|expand|conflict)[dq]){{end_b}}
      scope: keyword.operator.word.mnemonic.avx512.compress
    - match: (?i){{stt_b}}(vcvt(t?p[sd]2(udq|u?qq)|(udq|u?qq)2p[ds]|t?s[ds]2usi|usi2s[ds])){{end_b}}
      scope: keyword.operator.word.mnemonic.avx512.conversion
    - match: (?i){{stt_b}}(v(fixupimm|fpclass|get(exp|mant)|range|(rcp|rsqrt)(14|28)|reduce|rndscale|scalef)([ps][ds])){{end_b}}
      scope: keyword.operator.word.mnemonic.avx512.math
    - match: (?i){{stt_b}}(v(exp2p[ds]|(scatter|(gather|scatter)pf[01])[dq]p[ds])){{end_b}}
      scope: keyword.operator.word.mnemonic.avx512.math
    - match: (?i){{stt_b}}(vmovdq(a(32|64)|u(8|16|32|64))){{end_b}}
      scope: keyword.operator.word.mnemonic.avx512.simd-integer
    - match: (?i){{stt_b}}(vp(andn?|x?or)[dq]){{end_b}}
      scope: keyword.operator.word.mnemonic.avx512.logical
    - match: (?i){{stt_b}}(vpcmpu?[dqw]){{end_b}}
      scope: keyword.operator.word.mnemonic.avx512.packed-comparison
    - match: (?i){{stt_b}}(vp(absq|(lzcnt|ternlog)[dq]|madd52[lh]uq|(max|min)[su]q|mullq)){{end_b}}
      scope: keyword.operator.word.mnemonic.avx512.packed-math
    - match: (?i){{stt_b}}(vpmov(m2[bdqw]|[bdqw]2m|(u?s)?([qd][bw]|qd|wb))){{end_b}}
      scope: keyword.operator.word.mnemonic.avx512.packed-mov
    - match: (?i){{stt_b}}(vp(ro[rl]v?[dq]|scatter[dq][dq])){{end_b}}
      scope: keyword.operator.word.mnemonic.avx512.packed-shift
    - match: (?i){{stt_b}}(vptestn?m[bdqw]){{end_b}}
      scope: keyword.operator.word.mnemonic.avx512.packed-test
    - match: (?i){{stt_b}}(vperm([bdw]|[it]2([bdwq]|p[ds]))){{end_b}}
      scope: keyword.operator.word.mnemonic.avx512.permutations
    - match: (?i){{stt_b}}(valign[dq]|vdbpsadbw|vpmultishiftqb|vpsrav[dqw]){{end_b}}
      scope: keyword.operator.word.mnemonic.avx512.other
  mnemonics-future-intel-opmask:
    - match: (?i){{stt_b}}(k(add|andn?|(xn?)?or|mov|not|(or)?test|shift[lr])[bdqw]|kunpck(bw|wd|dq)){{end_b}}
      scope: keyword.operator.word.mnemonic.opmask
  mnemonics-future-intel-cet:
    - match: (?i){{stt_b}}((inc|save|rstor)ssp|wru?ss|(set|clr)ssbsy|endbranch|endbr(32|64)){{end_b}}
      scope: keyword.operator.word.mnemonic.cet
  mnemonics-future-intel-other:
    - match: (?i){{stt_b}}(clflushopt|clwb|pcommit){{end_b}}
      scope: keyword.operator.word.mnemonic.other
  mnemonics-pseudo-ops:
    - match: (?i){{stt_b}}(cmp(n?(eq|lt|le)|(un)?ord)[ps][ds]){{end_b}}
      scope: keyword.pseudo-mnemonic.sse2.compare
    - match: (?i){{stt_b}}(v?pclmul([hl]q[hl]q|[hl]qh)dq){{end_b}}
      scope: keyword.pseudo-mnemonic.avx.promoted.aes
    - match: (?i){{stt_b}}(vcmp(eq(_(os|uq|us))?|neq(_(oq|os|us))?|[gl][et](_oq)?|n[gl][et](_uq)?|(un)?ord(_s)?|false(_os)?|true(_us)?)[ps][ds]){{end_b}}
      scope: keyword.pseudo-mnemonic.avx.promoted.comparison
    - match: (?i){{stt_b}}(vpcom(n?eq|[gl][et]|false|true)(b|uw)){{end_b}}
      scope: keyword.pseudo-mnemonic.supplemental.amd.xop.simd
  mnemonics-invalid:
    - include: mnemonics-invalid-amd-sse5
  mnemonics-invalid-amd-sse5:
    - match: (?i){{stt_b}}(com[ps][ds]|pcomu?[bdqw]){{end_b}}
      scope: invalid.keyword.operator.word.mnemonic.sse5.comparison
    - match: (?i){{stt_b}}(cvtp(h2ps|s2ph)|frcz[ps][ds]){{end_b}}
      scope: invalid.keyword.operator.word.mnemonic.sse5.conversion
    - match: (?i){{stt_b}}(fn?m((add|sub)[ps][ds])|ph(addu?(b[dqw]|w[dq]|dq)|sub(bw|dq|wd))|pma(css?(d(d|q[hl])|w[dw])|dcss?wd)){{end_b}}
      scope: invalid.keyword.operator.word.mnemonic.sse5.packed-arithmetic
    - match: (?i){{stt_b}}(pcmov|permp[ds]|pperm|prot[bdqw]|psh[al][bdqw]){{end_b}}
      scope: invalid.keyword.operator.word.mnemonic.sse5.simd-integer
